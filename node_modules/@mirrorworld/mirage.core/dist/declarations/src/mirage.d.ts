/// <reference types="node" />
/// <reference types="@project-serum/anchor/node_modules/@solana/web3.js" />
/// <reference types="@metaplex-foundation/js/node_modules/@solana/web3.js" />
/// <reference types="@solana/spl-token/node_modules/@solana/web3.js" />
import { Metaplex, Nft } from '@metaplex-foundation/js';
import { Commitment, Connection, PublicKey, Transaction, RpcResponseAndContext, SignatureResult } from '@solana/web3.js';
import { Program, Provider } from '@project-serum/anchor';
import type { Wallet } from '@project-serum/anchor';
import { MetadataObject } from './types';
import { AuctionHouseProgramIDL } from './idl';
import { BidReceipt, ListingReceipt, PurchaseReceipt } from '@metaplex-foundation/mpl-auction-house/dist/src/generated/accounts';
export interface IMirageOptions {
    auctionHouseAuthority: PublicKey;
    connection: Connection;
    wallet: Wallet;
    NFTStorageAPIKey: string;
    mintConfig?: {
        seller_fee_basis_points: number;
        mintRoyalties: number;
    };
}
export declare type ReceiptType = 'purchase_receipt' | 'listing_receipt' | 'cancel_receipt' | 'cancel_listing_receipt' | 'bid_receipt' | 'cancel_bid_receipt';
export declare type ReceiptAddress = PublicKey;
export interface TransactionReceipt extends Omit<ListingReceipt, 'serialize' | 'pretty'>, Omit<BidReceipt, 'serialize' | 'pretty'>, Omit<PurchaseReceipt, 'serialize' | 'pretty'> {
    receipt_type: ReceiptType;
    createdAt: number;
    cancelledAt: number;
    price: number;
    tokenSize: number;
}
export declare type TransactionSignature = string | undefined;
export declare class Mirage {
    auctionHouseAuthority: PublicKey;
    auctionHouse?: PublicKey;
    _provider?: Provider;
    program?: Program<AuctionHouseProgramIDL>;
    connection: Connection;
    wallet: Wallet;
    NFTStorageAPIKey: string;
    mintConfig: IMirageOptions['mintConfig'];
    metaplex: Metaplex;
    constructor({ auctionHouseAuthority, connection, wallet, NFTStorageAPIKey, mintConfig: userMintConfig }: IMirageOptions);
    setup(): Promise<void>;
    /** Get user's NFTs */
    getUserNfts(publicKey: PublicKey): Promise<Nft[]>;
    /** Get single NFT by mint */
    getNft(mintKey: PublicKey): Promise<Nft>;
    /** Gets the owner of an NFT */
    getNftOwner(mint: string | PublicKey): Promise<readonly [string, PublicKey, Buffer | import("@solana/web3.js").ParsedAccountData]>;
    /** Determines whether the client is the owner of the auctionhouse */
    get clientIsOwner(): boolean;
    /** Get the auction house addresses by the owner */
    getAuctionHouseAddress(): Promise<[PublicKey, number]>;
    /** Loads provider instance */
    getProvider(commitment?: Commitment): Promise<Provider>;
    /** Loads auctionhouse program */
    loadAuctionHouseProgram(): Promise<Program<AuctionHouseProgramIDL>>;
    /**
     * Create listing transaction
     * @param mint
     * @param listingPrice
     * @param sellerPublicKey
     */
    createListTransaction(mint: PublicKey, listingPrice: number, sellerPublicKey: PublicKey): Promise<readonly [Transaction, PublicKey]>;
    /**
     * Lists an NFT for sale.
     * @param mint NFT mint address to be sold
     * @param _listingPrice price at which NFT will be sold
     */
    listToken(mint: string, _listingPrice: number): Promise<readonly [RpcResponseAndContext<any>, ReceiptAddress, TransactionSignature]>;
    /**
     * Creates Buy transaction Object
     * @param mint
     * @param listingPrice
     * @param buyerPublicKey
     * @param connection
     */
    createBuyTransaction(mint: PublicKey, listingPrice: number, buyerPublicKey: PublicKey, connection?: Connection): Promise<readonly [Transaction, PublicKey]>;
    /**
     * Creates Update Listing transaction Object
     * @param mint
     * @param currentListingPrice
     * @param newListingPrice
     * @param sellerPublicKey
     * @param auctionHouseAuthority
     * @param connection
     */
    createUpdateListingTransaction(mint: PublicKey, currentListingPrice: number, newListingPrice: number, sellerPublicKey: PublicKey, auctionHouseAuthority?: PublicKey, connection?: Connection): Promise<readonly [Transaction, PublicKey]>;
    /**
     * Purchases an NFT that has been listed on sale
     * @param mint NFT mint address to be bought
     * @param _buyerPrice price at which NFT will be bought. This MUST match the selling price of the NFT
     */
    buyToken(mint: string, _buyerPrice: number): Promise<readonly [RpcResponseAndContext<any>, ReceiptAddress, TransactionSignature]>;
    /**
     * Updates a current listing
     * @param mint
     * @param currentListingPrice
     * @param newListingPrice
     */
    updateListing(mint: string, currentListingPrice: number, newListingPrice: number): Promise<readonly [RpcResponseAndContext<any>, ReceiptAddress, TransactionSignature]>;
    /**
     * Creates Cancel Listing transaction Object
     * @param mint
     * @param currentListingPrice
     * @param sellerPublicKey
     * @param auctionHouseAuthority
     * @param connection
     * @param __DANGEROUSLY_INSET_SELLER__
     */
    createCancelListingTransaction(mint: PublicKey, currentListingPrice: number, sellerPublicKey: PublicKey, auctionHouseAuthority?: PublicKey, connection?: Connection, __DANGEROUSLY_INSET_SELLER__?: string): Promise<readonly [Transaction, PublicKey]>;
    /**
     * Cancels a listing for sell or buy instructions for an NFT
     * @param mint NFT mint address whose listing is to be cancelled
     * @param currentListingPrice price at which NFT was listed
     * @param tradeState optional: trade state address to cancel
     */
    cancelListing(mint: string, currentListingPrice: number, __DANGEROUSLY_INSET_SELLER__?: string): Promise<readonly [RpcResponseAndContext<any>, ReceiptAddress, TransactionSignature]>;
    /**
     * Creates Transfer transaction Object
     * @param mint
     * @param recipient
     * @param holderPublicKey
     * @param auctionHouseAuthority
     * @param connection
     * @param __DANGEROUSLY_INSET_SELLER__
     */
    createTransferTransaction(mint: PublicKey, recipient: PublicKey, holderPublicKey: PublicKey, auctionHouseAuthority?: PublicKey, connection?: Connection, __DANGEROUSLY_INSET_SELLER__?: string): Promise<Transaction>;
    /**
     * Sends an NFT to a enw user.
     * @param mint NFT mint address to transfer to a new user
     * @param recipient Recipient's publicKey
     */
    transferNft(mint: string | PublicKey, recipient: string | PublicKey): Promise<[RpcResponseAndContext<SignatureResult>, TransactionSignature]>;
    /**
     * Mints a new NFT on Solana. There are 2 approaches to using this function.
     * 1. If you already have your files uploaded to the blockchain, then there is no
     *    need to perform a new upload. Simply provide the necessary metadata URI / tokenURI.
     * 2. If you choose to provide a file/image/video for your NFT, then it will be uploaded
     *    to a decentralized storage service before minting.
     * @param metadata Object for metadata according to Metaplex NFT standard. @see https://docs.metaplex.com/token-metadata/specification#full-metadata-struct
     * @param metadataLink URL for your token metadata. If provided, then upload is ignored.
     * @param file
     */
    mintNft(metadata: MetadataObject, metadataLink?: string, file?: File): Promise<Nft>;
    /**
     * Get token transactions
     * @param mint
     */
    getTokenTransactions(mint: string | PublicKey): Promise<(TransactionReceipt | undefined)[]>;
    /**
     * Signs a transaction object
     * @param txt
     * @param wallet
     */
    signTransaction(txt: Transaction, wallet: Wallet): Promise<Buffer>;
}
