import { PublicKey, LAMPORTS_PER_SOL, clusterApiUrl, Transaction, SYSVAR_INSTRUCTIONS_PUBKEY, TransactionInstruction } from '@solana/web3.js';
import { Metaplex } from '@metaplex-foundation/js';
import { AuctionHouseProgram } from '@metaplex-foundation/mpl-auction-house';
import { BN, Provider, Program } from '@project-serum/anchor';
import merge from 'lodash.merge';
import { AccountLayout, TOKEN_PROGRAM_ID, Token, ASSOCIATED_TOKEN_PROGRAM_ID } from '@solana/spl-token';
import fetch from 'isomorphic-fetch';
import percentRound from 'percent-round';
import dayjs from 'dayjs';
import { programs, actions } from '@metaplex/js';
import { Transaction as Transaction$1, Borsh } from '@metaplex-foundation/mpl-core';
import { ENV } from '@solana/spl-token-registry';
import { WalletNotConnectedError } from '@solana/wallet-adapter-base';
import { deserializeUnchecked, BinaryReader, BinaryWriter } from 'borsh';
import base58 from 'bs58';
import { createCancelListingReceiptInstruction, createCancelInstruction, createPrintListingReceiptInstruction as createPrintListingReceiptInstruction$1, createSellInstruction as createSellInstruction$1 } from '@metaplex-foundation/mpl-auction-house/dist/src/generated/instructions';

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var AUCTION_HOUSE = 'auction_house';
var AUCTION_HOUSE_PROGRAM_ID = new PublicKey('hausS13jsjafwWwGqZTUQRmWyvyxn9EQpqMwV1PBBmk');
var TOKEN_METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');
var SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');
var WRAPPED_SOL_MINT = new PublicKey('So11111111111111111111111111111111111111112');
var MIRAGE_AUCTION_HOUSE = new PublicKey('FW6o4vELLA4NojBdTjNGz1F7apWoj6Jtwb1YNbSdyB1X');
var NFT_STORAGE_API_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJkaWQ6ZXRocjoweEZDQjI0MDFEMTRGODk3OUViNkEzNDdhMWQ3MEMxMjQzMWI1OUUwZkMiLCJpc3MiOiJuZnQtc3RvcmFnZSIsImlhdCI6MTY0OTA4OTIxMzMyNSwibmFtZSI6Ik1pcnJvcldvcmxkX0RldmVsb3BtZW50X0tleSJ9.COpqZqwBbDM1bBgYuIiaQxsGRQc0gphXGCBMsRhAHk8';
var MIRAGE_AUCTION_HOUSE_AUTHORITY = new PublicKey('Cq4P18vbjMQNE7J2nMme4RMpRyVFf8PGFNkvh5ecC4jF');
var MINT_CONFIG = {
  // Earns a 4.25% on royalty sales
  seller_fee_basis_points: 425,
  mintRoyalties: 4.25
};

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var Metadata$2 = programs.metadata.Metadata;
/** Get metadatata account for mint */

var getMetadata = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mint) {
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return PublicKey.findProgramAddress([Buffer.from('metadata'), TOKEN_METADATA_PROGRAM_ID.toBuffer(), mint.toBuffer()], TOKEN_METADATA_PROGRAM_ID);

          case 2:
            return _context.abrupt("return", _context.sent[0]);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getMetadata(_x) {
    return _ref.apply(this, arguments);
  };
}();
/** Get associated token for mint */

var getAtaForMint = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(mint, address) {
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return PublicKey.findProgramAddress([address.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);

          case 2:
            return _context2.abrupt("return", _context2.sent);

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function getAtaForMint(_x2, _x3) {
    return _ref2.apply(this, arguments);
  };
}();
var getAuctionHouseProgramAsSigner = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _context3.next = 2;
            return PublicKey.findProgramAddress([Buffer.from(AUCTION_HOUSE), Buffer.from('signer')], AUCTION_HOUSE_PROGRAM_ID);

          case 2:
            return _context3.abrupt("return", _context3.sent);

          case 3:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function getAuctionHouseProgramAsSigner() {
    return _ref3.apply(this, arguments);
  };
}();
var getAuctionHouseTradeState = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(auctionHouse, wallet, tokenAccount, treasuryMint, tokenMint, tokenSize, buyPrice) {
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.next = 2;
            return PublicKey.findProgramAddress([Buffer.from(AUCTION_HOUSE), wallet.toBuffer(), auctionHouse.toBuffer(), tokenAccount.toBuffer(), treasuryMint.toBuffer(), tokenMint.toBuffer(), buyPrice.toBuffer('le', 8), tokenSize.toBuffer('le', 8)], AUCTION_HOUSE_PROGRAM_ID);

          case 2:
            return _context4.abrupt("return", _context4.sent);

          case 3:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function getAuctionHouseTradeState(_x4, _x5, _x6, _x7, _x8, _x9, _x10) {
    return _ref4.apply(this, arguments);
  };
}();
var getAuctionHouseBuyerEscrow = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(auctionHouse, wallet) {
    return regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return PublicKey.findProgramAddress([Buffer.from(AUCTION_HOUSE), auctionHouse.toBuffer(), wallet.toBuffer()], AUCTION_HOUSE_PROGRAM_ID);

          case 2:
            return _context5.abrupt("return", _context5.sent);

          case 3:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));

  return function getAuctionHouseBuyerEscrow(_x11, _x12) {
    return _ref5.apply(this, arguments);
  };
}();
var AccountState;

(function (AccountState) {
  AccountState[AccountState["Uninitialized"] = 0] = "Uninitialized";
  AccountState[AccountState["Initialized"] = 1] = "Initialized";
  AccountState[AccountState["Frozen"] = 2] = "Frozen";
})(AccountState || (AccountState = {}));

function getAccountInfo(_x13, _x14, _x15) {
  return _getAccountInfo.apply(this, arguments);
}
/**
 * Uploads an NFT's image or video or file to decentralized storage.
 * @param nftStorageKey API key provided by `https://nft.storage`. See documentation at:
 */

function _getAccountInfo() {
  _getAccountInfo = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(connection, address, commitment) {
    var programId,
        info,
        rawAccount,
        _args6 = arguments;
    return regeneratorRuntime.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            programId = _args6.length > 3 && _args6[3] !== undefined ? _args6[3] : TOKEN_PROGRAM_ID;
            _context6.next = 3;
            return connection.getAccountInfo(address, commitment);

          case 3:
            info = _context6.sent;

            if (info) {
              _context6.next = 6;
              break;
            }

            throw new Error('TokenAccountNotFoundError');

          case 6:
            if (info.owner.equals(programId)) {
              _context6.next = 8;
              break;
            }

            throw new Error('TokenInvalidAccountOwnerError');

          case 8:
            if (!(info.data.length != AccountLayout.span)) {
              _context6.next = 10;
              break;
            }

            throw new Error('TokenInvalidAccountSizeError');

          case 10:
            rawAccount = AccountLayout.decode(Buffer.from(info.data));
            return _context6.abrupt("return", {
              address: address,
              mint: rawAccount.mint,
              owner: rawAccount.owner,
              amount: rawAccount.amount,
              delegate: rawAccount.delegateOption ? rawAccount.delegate : null,
              delegatedAmount: rawAccount.delegatedAmount,
              isInitialized: rawAccount.state !== AccountState.Uninitialized,
              isFrozen: rawAccount.state === AccountState.Frozen,
              isNative: !!rawAccount.isNativeOption,
              rentExemptReserve: rawAccount.isNativeOption ? rawAccount.isNative : null,
              closeAuthority: rawAccount.closeAuthorityOption ? rawAccount.closeAuthority : null
            });

          case 12:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _getAccountInfo.apply(this, arguments);
}

function uploadNFTFileToStorage(_x16, _x17) {
  return _uploadNFTFileToStorage.apply(this, arguments);
}
/**
 * Processes creator shares and adds the auctionhouse as one of the authorities on the
 * mint. It then provides the `authorityAddress` and gives it a royalty percentage equal to
 * the `authorityRoyaltyPercentage` of the cumulative total shares of all the `creators`.
 *
 * e.g.
 * @param creators Array of creators
 * @param authorityAddress Address of the auctionhouse authority
 * @param authorityRoyaltyPercentage Percentage of royalties to be added to the marketplace
 * @example
 * ```ts
 *  const auctionHouseAuthority = new PublicKey("3MtckfRX4VRJ1yUmPHpKZstAQ8S3WfhRnNJLT8LqTZEr")
    const authorityRoyaltyPercentage = 5

    processCreatorShares([
      {
        address: "Betkx8CfRUwQAqZZRqKt13zo4t9awNFeriD2bMAq2xfJ",
        share: 43
      },
      {
        address: "Dn4D8vVvpKzCALq1X5jasPrwvs5kXnSJtfbji4iZaq6R",
        share: 1232
      }
    ], auctionHouseAuthority, authorityRoyaltyPercentage);
 * ```
    Yields:
    ```ts
    [
      {
        address: 'Betkx8CfRUwQAqZZRqKt13zo4t9awNFeriD2bMAq2xfJ',
        share: 3
      },
      {
        address: 'Dn4D8vVvpKzCALq1X5jasPrwvs5kXnSJtfbji4iZaq6R',
        share: 92
      },
      {
        address: '3MtckfRX4VRJ1yUmPHpKZstAQ8S3WfhRnNJLT8LqTZEr',
        share: 5
      }
    ]
    ```
 */

function _uploadNFTFileToStorage() {
  _uploadNFTFileToStorage = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(image, metadataJson) {
    var nftStorageKey,
        uploadImage,
        uploadMetadata,
        _yield$Promise$all,
        _yield$Promise$all2,
        imageUrl,
        metadataUrl,
        _metadataUrl,
        _args9 = arguments;

    return regeneratorRuntime.wrap(function _callee9$(_context9) {
      while (1) {
        switch (_context9.prev = _context9.next) {
          case 0:
            nftStorageKey = _args9.length > 3 && _args9[3] !== undefined ? _args9[3] : NFT_STORAGE_API_KEY;

            // 1. Uploads image file to
            uploadImage = /*#__PURE__*/function () {
              var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(media) {
                var response, image, imageUrl;
                return regeneratorRuntime.wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        _context7.next = 2;
                        return fetch('https://api.nft.storage/upload', {
                          method: 'POST',
                          headers: {
                            'Content-Length': String(media.size),
                            Authorization: "Bearer ".concat(nftStorageKey)
                          },
                          body: media
                        });

                      case 2:
                        response = _context7.sent;
                        _context7.next = 5;
                        return response.json();

                      case 5:
                        image = _context7.sent;
                        imageUrl = "https://".concat(image.value.cid, ".ipfs.dweb.link");
                        return _context7.abrupt("return", imageUrl);

                      case 8:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              return function uploadImage(_x23) {
                return _ref6.apply(this, arguments);
              };
            }(); // 2. Upload metadtaa object


            uploadMetadata = /*#__PURE__*/function () {
              var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(metadataJson) {
                var payload, response, metadata, metadataUrl;
                return regeneratorRuntime.wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        payload = Buffer.from(JSON.stringify(metadataJson));
                        _context8.next = 3;
                        return fetch('https://api.nft.storage/upload', {
                          method: 'POST',
                          headers: {
                            'Content-Length': String(payload.length),
                            Authorization: "Bearer ".concat(nftStorageKey)
                          },
                          body: payload
                        });

                      case 3:
                        response = _context8.sent;
                        _context8.next = 6;
                        return response.json();

                      case 6:
                        metadata = _context8.sent;
                        metadataUrl = "https://".concat(metadata.value.cid, ".ipfs.dweb.link");
                        return _context8.abrupt("return", metadataUrl);

                      case 9:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8);
              }));

              return function uploadMetadata(_x24) {
                return _ref7.apply(this, arguments);
              };
            }();

            if (!(image && metadataJson)) {
              _context9.next = 14;
              break;
            }

            _context9.next = 7;
            return Promise.all([uploadImage(image), uploadMetadata(metadataJson)]);

          case 7:
            _yield$Promise$all = _context9.sent;
            _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);
            imageUrl = _yield$Promise$all2[0];
            metadataUrl = _yield$Promise$all2[1];
            return _context9.abrupt("return", [imageUrl, metadataUrl]);

          case 14:
            if (!(metadataJson && !image)) {
              _context9.next = 19;
              break;
            }

            _context9.next = 17;
            return uploadMetadata(metadataJson);

          case 17:
            _metadataUrl = _context9.sent;
            return _context9.abrupt("return", [_metadataUrl]);

          case 19:
          case "end":
            return _context9.stop();
        }
      }
    }, _callee9);
  }));
  return _uploadNFTFileToStorage.apply(this, arguments);
}

function processCreatorShares(creators, authorityAddress) {
  var authorityRoyaltyPercentage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4.25;

  if (authorityRoyaltyPercentage > 99) {
    throw new Error('royalty percentage cannot exceed 99%!');
  }

  var originalShares = creators.map(function (c) {
    return c.share;
  });
  var originalSum = originalShares.reduce(function (acc, curr) {
    return acc += curr;
  }, 0);
  /** MirrorWorld takes a 4.25% royalty on the NFT */

  var mirrorWorldShare = originalSum * (authorityRoyaltyPercentage / 100);
  var finalCreators = creators.concat({
    address: authorityAddress.toBase58(),
    share: mirrorWorldShare
  });
  var shares = finalCreators.map(function (c) {
    return c.share;
  });
  var rounded = percentRound(shares);
  var finalCreatorsWithShares = rounded.map(function (p, i) {
    return {
      address: finalCreators[i].address,
      share: p
    };
  });
  return finalCreatorsWithShares;
}
/* Get NFT Owner */

function getNftOwner(_x18, _x19) {
  return _getNftOwner.apply(this, arguments);
}
/**
 * Get Token Transactions
 * @param mint
 * @param auctionHouse
 * @param connection
 */

function _getNftOwner() {
  _getNftOwner = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(mint, connection) {
    var largestAccounts, largestAccountInfo, owner;
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            _context10.next = 2;
            return connection.getTokenLargestAccounts(new PublicKey(mint));

          case 2:
            largestAccounts = _context10.sent;
            _context10.next = 5;
            return connection.getParsedAccountInfo(largestAccounts.value[0].address);

          case 5:
            largestAccountInfo = _context10.sent;

            /** @ts-expect-error "ParsedAccountInfo | Buffer" not typed correctly */
            owner = largestAccountInfo.value.data.parsed.info.owner;
            console.log("Owner of token ".concat(mint.toString(), " is ").concat(owner));
            return _context10.abrupt("return", [owner, new PublicKey(owner), largestAccountInfo.value.data]);

          case 9:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10);
  }));
  return _getNftOwner.apply(this, arguments);
}

function getTokenTransactions(_x20, _x21, _x22) {
  return _getTokenTransactions.apply(this, arguments);
}

function _getTokenTransactions() {
  _getTokenTransactions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(mint, auctionHouse, connection) {
    var _mint, metadata, PrintListingReceiptSize, PrintBidReceiptSize, PrintPurchaseReceiptSize, ReceiptAccountSizes, ReceiptAccounts, result;

    return regeneratorRuntime.wrap(function _callee13$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            _mint = new PublicKey(mint);
            _context13.next = 3;
            return Metadata$2.findByMint(connection, _mint);

          case 3:
            metadata = _context13.sent;

            /**
             * Allocated data size on auction_house program per PDA type
             * CreateAuctionHouse: 459
             * PrintListingReceipt: 236
             * PrintBidReceipt: 269
             * PrintPurchaseReceipt: 193
             */
            PrintListingReceiptSize = 236;
            PrintBidReceiptSize = 269;
            PrintPurchaseReceiptSize = 193;
            ReceiptAccountSizes = [PrintListingReceiptSize, PrintBidReceiptSize, PrintPurchaseReceiptSize];
            _context13.next = 10;
            return ReceiptAccountSizes.map( /*#__PURE__*/function () {
              var _ref8 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(size) {
                var accounts, parsedAccounts;
                return regeneratorRuntime.wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        _context12.next = 2;
                        return connection.getProgramAccounts(AUCTION_HOUSE_PROGRAM_ID, {
                          commitment: 'confirmed',
                          filters: [{
                            dataSize: size
                          }]
                        });

                      case 2:
                        accounts = _context12.sent;
                        _context12.next = 5;
                        return accounts.map( /*#__PURE__*/function () {
                          var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(account) {
                            var _yield$AuctionHousePr, _yield$AuctionHousePr2, ListingReceipt, _yield$AuctionHousePr3, _yield$AuctionHousePr4, BidReceipt, _yield$AuctionHousePr5, _yield$AuctionHousePr6, PurchaseReceipt;

                            return regeneratorRuntime.wrap(function _callee11$(_context11) {
                              while (1) {
                                switch (_context11.prev = _context11.next) {
                                  case 0:
                                    _context11.t0 = size;
                                    _context11.next = _context11.t0 === PrintListingReceiptSize ? 3 : _context11.t0 === PrintBidReceiptSize ? 10 : _context11.t0 === PrintPurchaseReceiptSize ? 17 : 23;
                                    break;

                                  case 3:
                                    _context11.next = 5;
                                    return AuctionHouseProgram.accounts.ListingReceipt.fromAccountInfo(account.account);

                                  case 5:
                                    _yield$AuctionHousePr = _context11.sent;
                                    _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 1);
                                    ListingReceipt = _yield$AuctionHousePr2[0];
                                    return _context11.abrupt("return", _objectSpread2(_objectSpread2({}, ListingReceipt), {}, {
                                      receipt_type: ListingReceipt.canceledAt ? 'cancel_listing_receipt' : 'listing_receipt'
                                    }));

                                  case 10:
                                    _context11.next = 12;
                                    return AuctionHouseProgram.accounts.BidReceipt.fromAccountInfo(account.account);

                                  case 12:
                                    _yield$AuctionHousePr3 = _context11.sent;
                                    _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 1);
                                    BidReceipt = _yield$AuctionHousePr4[0];
                                    return _context11.abrupt("return", _objectSpread2(_objectSpread2({}, BidReceipt), {}, {
                                      receipt_type: 'bid_receipt'
                                    }));

                                  case 17:
                                    _context11.next = 19;
                                    return AuctionHouseProgram.accounts.PurchaseReceipt.fromAccountInfo(account.account);

                                  case 19:
                                    _yield$AuctionHousePr5 = _context11.sent;
                                    _yield$AuctionHousePr6 = _slicedToArray(_yield$AuctionHousePr5, 1);
                                    PurchaseReceipt = _yield$AuctionHousePr6[0];
                                    return _context11.abrupt("return", _objectSpread2(_objectSpread2({}, PurchaseReceipt), {}, {
                                      receipt_type: 'purchase_receipt'
                                    }));

                                  case 23:
                                    return _context11.abrupt("return", undefined);

                                  case 25:
                                  case "end":
                                    return _context11.stop();
                                }
                              }
                            }, _callee11);
                          }));

                          return function (_x26) {
                            return _ref9.apply(this, arguments);
                          };
                        }());

                      case 5:
                        parsedAccounts = _context12.sent;
                        _context12.next = 8;
                        return Promise.all(parsedAccounts);

                      case 8:
                        return _context12.abrupt("return", _context12.sent);

                      case 9:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12);
              }));

              return function (_x25) {
                return _ref8.apply(this, arguments);
              };
            }());

          case 10:
            ReceiptAccounts = _context13.sent;
            _context13.next = 13;
            return Promise.all(ReceiptAccounts);

          case 13:
            _context13.next = 15;
            return _context13.sent.flat().filter(function (receipt) {
              return !!receipt && receipt.metadata.toBase58() === metadata.pubkey.toBase58();
            }).map(function (receipt) {
              var _receipt$canceledAt, _receipt$canceledAt$t;

              return _objectSpread2(_objectSpread2({}, receipt), {}, {
                /** @ts-ignore */
                tokenSize: receipt.tokenSize.toNumber(),

                /** @ts-ignore */
                price: receipt.price.toNumber() / LAMPORTS_PER_SOL,

                /** @ts-ignore */
                createdAt: dayjs.unix(receipt.createdAt.toNumber()).toDate().getTime(),
                cancelledAt: dayjs
                /** @ts-ignore */
                .unix((_receipt$canceledAt = receipt.canceledAt) === null || _receipt$canceledAt === void 0 ? void 0 : (_receipt$canceledAt$t = _receipt$canceledAt.toNumber) === null || _receipt$canceledAt$t === void 0 ? void 0 : _receipt$canceledAt$t.call(_receipt$canceledAt)).toDate().getTime()
              });
            }).filter(function (receipt) {
              return receipt.auctionHouse.toBase58() === auctionHouse.toBase58();
            }).sort(function (a, b) {
              if (a.receipt_type === 'bid_receipt', b.receipt_type === 'purchase_receipt') {
                return 1;
              } else if (a.receipt_type === 'purchase_receipt', b.receipt_type === 'bid_receipt') {
                return -1;
              } else {
                return 0;
              }
            }).sort(function (a, b) {
              return b.createdAt - a.createdAt;
            });

          case 15:
            result = _context13.sent;
            console.log('result', result);
            return _context13.abrupt("return", result);

          case 18:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee13);
  }));
  return _getTokenTransactions.apply(this, arguments);
}

var AuctionHouseIDL = {
  version: '1.1.4',
  name: 'auction_house',
  instructions: [{
    name: 'withdrawFromFee',
    accounts: [{
      name: 'authority',
      isMut: false,
      isSigner: true
    }, {
      name: 'feeWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: true,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'amount',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'withdrawFromTreasury',
    accounts: [{
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: true
    }, {
      name: 'treasuryWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouseTreasury',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'amount',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'updateAuctionHouse',
    accounts: [{
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'payer',
      isMut: false,
      isSigner: true
    }, {
      name: 'authority',
      isMut: false,
      isSigner: true
    }, {
      name: 'newAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'feeWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryWithdrawalDestinationOwner',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ataProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'sellerFeeBasisPoints',
      type: {
        option: 'u16'
      }
    }, {
      name: 'requiresSignOff',
      type: {
        option: 'bool'
      }
    }, {
      name: 'canChangeSalePrice',
      type: {
        option: 'bool'
      }
    }],
    returns: null
  }, {
    name: 'createAuctionHouse',
    accounts: [{
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'payer',
      isMut: true,
      isSigner: true
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'feeWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryWithdrawalDestination',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryWithdrawalDestinationOwner',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouseTreasury',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ataProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'bump',
      type: 'u8'
    }, {
      name: 'feePayerBump',
      type: 'u8'
    }, {
      name: 'treasuryBump',
      type: 'u8'
    }, {
      name: 'sellerFeeBasisPoints',
      type: 'u16'
    }, {
      name: 'requiresSignOff',
      type: 'bool'
    }, {
      name: 'canChangeSalePrice',
      type: 'bool'
    }],
    returns: null
  }, {
    name: 'withdraw',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: false
    }, {
      name: 'receiptAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ataProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'escrowPaymentBump',
      type: 'u8'
    }, {
      name: 'amount',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'deposit',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: true
    }, {
      name: 'paymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'transferAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'escrowPaymentBump',
      type: 'u8'
    }, {
      name: 'amount',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'cancel',
    accounts: [{
      name: 'wallet',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'buyerPrice',
      type: 'u64'
    }, {
      name: 'tokenSize',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'executeSale',
    accounts: [{
      name: 'buyer',
      isMut: true,
      isSigner: false
    }, {
      name: 'seller',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'metadata',
      isMut: false,
      isSigner: false
    }, {
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'sellerPaymentReceiptAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerReceiptTokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouseTreasury',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'sellerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'freeTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'ataProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'programAsSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'escrowPaymentBump',
      type: 'u8'
    }, {
      name: 'freeTradeStateBump',
      type: 'u8'
    }, {
      name: 'programAsSignerBump',
      type: 'u8'
    }, {
      name: 'buyerPrice',
      type: 'u64'
    }, {
      name: 'tokenSize',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'sell',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'metadata',
      isMut: false,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'sellerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'freeSellerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'programAsSigner',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'tradeStateBump',
      type: 'u8'
    }, {
      name: 'freeTradeStateBump',
      type: 'u8'
    }, {
      name: 'programAsSignerBump',
      type: 'u8'
    }, {
      name: 'buyerPrice',
      type: 'u64'
    }, {
      name: 'tokenSize',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'buy',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: true
    }, {
      name: 'paymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'transferAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'metadata',
      isMut: false,
      isSigner: false
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'tradeStateBump',
      type: 'u8'
    }, {
      name: 'escrowPaymentBump',
      type: 'u8'
    }, {
      name: 'buyerPrice',
      type: 'u64'
    }, {
      name: 'tokenSize',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'publicBuy',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: true
    }, {
      name: 'paymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'transferAuthority',
      isMut: false,
      isSigner: false
    }, {
      name: 'treasuryMint',
      isMut: false,
      isSigner: false
    }, {
      name: 'tokenAccount',
      isMut: false,
      isSigner: false
    }, {
      name: 'metadata',
      isMut: false,
      isSigner: false
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'authority',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'auctionHouseFeeAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'buyerTradeState',
      isMut: true,
      isSigner: false
    }, {
      name: 'tokenProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'tradeStateBump',
      type: 'u8'
    }, {
      name: 'escrowPaymentBump',
      type: 'u8'
    }, {
      name: 'buyerPrice',
      type: 'u64'
    }, {
      name: 'tokenSize',
      type: 'u64'
    }],
    returns: null
  }, {
    name: 'closeEscrowAccount',
    accounts: [{
      name: 'wallet',
      isMut: false,
      isSigner: true
    }, {
      name: 'escrowPaymentAccount',
      isMut: true,
      isSigner: false
    }, {
      name: 'auctionHouse',
      isMut: false,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'escrowPaymentBump',
      type: 'u8'
    }],
    returns: null
  }, {
    name: 'printListingReceipt',
    accounts: [{
      name: 'receipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'bookkeeper',
      isMut: true,
      isSigner: true
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }, {
      name: 'instruction',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'receiptBump',
      type: 'u8'
    }],
    returns: null
  }, {
    name: 'cancelListingReceipt',
    accounts: [{
      name: 'receipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'instruction',
      isMut: false,
      isSigner: false
    }],
    args: [],
    returns: null
  }, {
    name: 'printBidReceipt',
    accounts: [{
      name: 'receipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'bookkeeper',
      isMut: true,
      isSigner: true
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }, {
      name: 'instruction',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'receiptBump',
      type: 'u8'
    }],
    returns: null
  }, {
    name: 'cancelBidReceipt',
    accounts: [{
      name: 'receipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'instruction',
      isMut: false,
      isSigner: false
    }],
    args: [],
    returns: null
  }, {
    name: 'printPurchaseReceipt',
    accounts: [{
      name: 'purchaseReceipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'listingReceipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'bidReceipt',
      isMut: true,
      isSigner: false
    }, {
      name: 'bookkeeper',
      isMut: true,
      isSigner: true
    }, {
      name: 'systemProgram',
      isMut: false,
      isSigner: false
    }, {
      name: 'rent',
      isMut: false,
      isSigner: false
    }, {
      name: 'instruction',
      isMut: false,
      isSigner: false
    }],
    args: [{
      name: 'purchaseReceiptBump',
      type: 'u8'
    }],
    returns: null
  }],
  accounts: [{
    name: 'BidReceipt',
    type: {
      kind: 'struct',
      fields: [{
        name: 'tradeState',
        type: 'publicKey'
      }, {
        name: 'bookkeeper',
        type: 'publicKey'
      }, {
        name: 'auctionHouse',
        type: 'publicKey'
      }, {
        name: 'buyer',
        type: 'publicKey'
      }, {
        name: 'metadata',
        type: 'publicKey'
      }, {
        name: 'tokenAccount',
        type: {
          option: 'publicKey'
        }
      }, {
        name: 'purchaseReceipt',
        type: {
          option: 'publicKey'
        }
      }, {
        name: 'price',
        type: 'u64'
      }, {
        name: 'tokenSize',
        type: 'u64'
      }, {
        name: 'bump',
        type: 'u8'
      }, {
        name: 'tradeStateBump',
        type: 'u8'
      }, {
        name: 'createdAt',
        type: 'i64'
      }, {
        name: 'canceledAt',
        type: {
          option: 'i64'
        }
      }]
    }
  }, {
    name: 'ListingReceipt',
    type: {
      kind: 'struct',
      fields: [{
        name: 'tradeState',
        type: 'publicKey'
      }, {
        name: 'bookkeeper',
        type: 'publicKey'
      }, {
        name: 'auctionHouse',
        type: 'publicKey'
      }, {
        name: 'seller',
        type: 'publicKey'
      }, {
        name: 'metadata',
        type: 'publicKey'
      }, {
        name: 'purchaseReceipt',
        type: {
          option: 'publicKey'
        }
      }, {
        name: 'price',
        type: 'u64'
      }, {
        name: 'tokenSize',
        type: 'u64'
      }, {
        name: 'bump',
        type: 'u8'
      }, {
        name: 'tradeStateBump',
        type: 'u8'
      }, {
        name: 'createdAt',
        type: 'i64'
      }, {
        name: 'canceledAt',
        type: {
          option: 'i64'
        }
      }]
    }
  }, {
    name: 'PurchaseReceipt',
    type: {
      kind: 'struct',
      fields: [{
        name: 'bookkeeper',
        type: 'publicKey'
      }, {
        name: 'buyer',
        type: 'publicKey'
      }, {
        name: 'seller',
        type: 'publicKey'
      }, {
        name: 'auctionHouse',
        type: 'publicKey'
      }, {
        name: 'metadata',
        type: 'publicKey'
      }, {
        name: 'tokenSize',
        type: 'u64'
      }, {
        name: 'price',
        type: 'u64'
      }, {
        name: 'bump',
        type: 'u8'
      }, {
        name: 'createdAt',
        type: 'i64'
      }]
    }
  }, {
    name: 'auctionHouse',
    type: {
      kind: 'struct',
      fields: [{
        name: 'auctionHouseFeeAccount',
        type: 'publicKey'
      }, {
        name: 'auctionHouseTreasury',
        type: 'publicKey'
      }, {
        name: 'treasuryWithdrawalDestination',
        type: 'publicKey'
      }, {
        name: 'feeWithdrawalDestination',
        type: 'publicKey'
      }, {
        name: 'treasuryMint',
        type: 'publicKey'
      }, {
        name: 'authority',
        type: 'publicKey'
      }, {
        name: 'creator',
        type: 'publicKey'
      }, {
        name: 'bump',
        type: 'u8'
      }, {
        name: 'treasuryBump',
        type: 'u8'
      }, {
        name: 'feePayerBump',
        type: 'u8'
      }, {
        name: 'sellerFeeBasisPoints',
        type: 'u16'
      }, {
        name: 'requiresSignOff',
        type: 'bool'
      }, {
        name: 'canChangeSalePrice',
        type: 'bool'
      }]
    }
  }],
  types: [{
    name: 'BidType',
    type: {
      kind: 'enum',
      variants: [{
        name: 'PublicSale'
      }, {
        name: 'PrivateSale'
      }]
    }
  }],
  errors: [{
    code: 6000,
    name: 'PublicKeyMismatch',
    msg: 'PublicKeyMismatch'
  }, {
    code: 6001,
    name: 'InvalidMintAuthority',
    msg: 'InvalidMintAuthority'
  }, {
    code: 6002,
    name: 'UninitializedAccount',
    msg: 'UninitializedAccount'
  }, {
    code: 6003,
    name: 'IncorrectOwner',
    msg: 'IncorrectOwner'
  }, {
    code: 6004,
    name: 'PublicKeysShouldBeUnique',
    msg: 'PublicKeysShouldBeUnique'
  }, {
    code: 6005,
    name: 'StatementFalse',
    msg: 'StatementFalse'
  }, {
    code: 6006,
    name: 'NotRentExempt',
    msg: 'NotRentExempt'
  }, {
    code: 6007,
    name: 'NumericalOverflow',
    msg: 'NumericalOverflow'
  }, {
    code: 6008,
    name: 'ExpectedSolAccount',
    msg: 'Expected a sol account but got an spl token account instead'
  }, {
    code: 6009,
    name: 'CannotExchangeSOLForSol',
    msg: 'Cannot exchange sol for sol'
  }, {
    code: 6010,
    name: 'SOLWalletMustSign',
    msg: 'If paying with sol, sol wallet must be signer'
  }, {
    code: 6011,
    name: 'CannotTakeThisActionWithoutAuctionHouseSignOff',
    msg: 'Cannot take this action without auction house signing too'
  }, {
    code: 6012,
    name: 'NoPayerPresent',
    msg: 'No payer present on this txn'
  }, {
    code: 6013,
    name: 'DerivedKeyInvalid',
    msg: 'Derived key invalid'
  }, {
    code: 6014,
    name: 'MetadataDoesntExist',
    msg: "Metadata doesn't exist"
  }, {
    code: 6015,
    name: 'InvalidTokenAmount',
    msg: 'Invalid token amount'
  }, {
    code: 6016,
    name: 'BothPartiesNeedToAgreeToSale',
    msg: 'Both parties need to agree to this sale'
  }, {
    code: 6017,
    name: 'CannotMatchFreeSalesWithoutAuctionHouseOrSellerSignoff',
    msg: 'Cannot match free sales unless the auction house or seller signs off'
  }, {
    code: 6018,
    name: 'SaleRequiresSigner',
    msg: 'This sale requires a signer'
  }, {
    code: 6019,
    name: 'OldSellerNotInitialized',
    msg: 'Old seller not initialized'
  }, {
    code: 6020,
    name: 'SellerATACannotHaveDelegate',
    msg: 'Seller ata cannot have a delegate set'
  }, {
    code: 6021,
    name: 'BuyerATACannotHaveDelegate',
    msg: 'Buyer ata cannot have a delegate set'
  }, {
    code: 6022,
    name: 'NoValidSignerPresent',
    msg: 'No valid signer present'
  }, {
    code: 6023,
    name: 'InvalidBasisPoints',
    msg: 'BP must be less than or equal to 10000'
  }, {
    code: 6024,
    name: 'TradeStateDoesntExist',
    msg: 'The trade state account does not exist'
  }, {
    code: 6025,
    name: 'TradeStateIsNotEmpty',
    msg: 'The trade state is not empty'
  }, {
    code: 6026,
    name: 'ReceiptIsEmpty',
    msg: 'The receipt is empty'
  }, {
    code: 6027,
    name: 'InstructionMismatch',
    msg: 'The instruction does not match'
  }, {
    code: 6028,
    name: 'EscrowUnderRentExemption',
    msg: 'The instruction would drain the escrow below rent exemption threshold'
  }]
};

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var ENDPOINTS = [{
  name: 'mainnet-beta',
  label: 'mainnet-beta',
  url: 'https://api.metaplex.solana.com/',
  chainId: ENV.MainnetBeta
}, {
  name: 'testnet',
  label: 'testnet',
  url: clusterApiUrl('testnet'),
  chainId: ENV.Testnet
}, {
  name: 'devnet',
  label: 'devnet',
  url: clusterApiUrl('devnet'),
  chainId: ENV.Devnet
}];
ENDPOINTS[0];
var getErrorForTransaction = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(connection, txid) {
    var tx, errors;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return connection.confirmTransaction(txid, 'max');

          case 2:
            _context.next = 4;
            return connection.getParsedConfirmedTransaction(txid);

          case 4:
            tx = _context.sent;
            errors = [];

            if (tx !== null && tx !== void 0 && tx.meta && tx.meta.logMessages) {
              tx.meta.logMessages.forEach(function (log) {
                var regex = /Error: (.*)/gm;
                var m;

                while ((m = regex.exec(log)) !== null) {
                  // This is necessary to avoid infinite loops with zero-width matches
                  if (m.index === regex.lastIndex) {
                    regex.lastIndex++;
                  }

                  if (m.length > 1) {
                    errors.push(m[1]);
                  }
                }
              });
            }

            return _context.abrupt("return", errors);

          case 8:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function getErrorForTransaction(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();
var SequenceType;

(function (SequenceType) {
  SequenceType[SequenceType["Sequential"] = 0] = "Sequential";
  SequenceType[SequenceType["Parallel"] = 1] = "Parallel";
  SequenceType[SequenceType["StopOnFailure"] = 2] = "StopOnFailure";
})(SequenceType || (SequenceType = {}));

function sendTransactionsWithManualRetry(_x3, _x4, _x5, _x6) {
  return _sendTransactionsWithManualRetry.apply(this, arguments);
}

function _sendTransactionsWithManualRetry() {
  _sendTransactionsWithManualRetry = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(connection, wallet, instructions, signers) {
    var stopPoint, tries, lastInstructionsLength, toRemoveSigners, filteredSigners;
    return regeneratorRuntime.wrap(function _callee7$(_context13) {
      while (1) {
        switch (_context13.prev = _context13.next) {
          case 0:
            stopPoint = 0;
            tries = 0;
            lastInstructionsLength = null;
            toRemoveSigners = {};
            instructions = instructions.filter(function (instr, i) {
              if (instr.length > 0) {
                return true;
              } else {
                toRemoveSigners[i] = true;
                return false;
              }
            });
            filteredSigners = signers.filter(function (_, i) {
              return !toRemoveSigners[i];
            });

          case 6:
            if (!(stopPoint < instructions.length && tries < 3)) {
              _context13.next = 29;
              break;
            }

            instructions = instructions.slice(stopPoint, instructions.length);
            filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);
            if (instructions.length === lastInstructionsLength) tries = tries + 1;else tries = 0;
            _context13.prev = 10;

            if (!(instructions.length === 1)) {
              _context13.next = 17;
              break;
            }

            _context13.next = 14;
            return sendTransactionWithRetry(connection, wallet, instructions[0], filteredSigners[0], 'single');

          case 14:
            stopPoint = 1;
            _context13.next = 20;
            break;

          case 17:
            _context13.next = 19;
            return sendTransactions(connection, wallet, instructions, filteredSigners, SequenceType.StopOnFailure, 'single');

          case 19:
            stopPoint = _context13.sent;

          case 20:
            _context13.next = 25;
            break;

          case 22:
            _context13.prev = 22;
            _context13.t0 = _context13["catch"](10);
            console.error(_context13.t0);

          case 25:
            console.log('Died on ', stopPoint, 'retrying from instruction', instructions[stopPoint], 'instructions length is', instructions.length);
            lastInstructionsLength = instructions.length;
            _context13.next = 6;
            break;

          case 29:
          case "end":
            return _context13.stop();
        }
      }
    }, _callee7, null, [[10, 22]]);
  }));
  return _sendTransactionsWithManualRetry.apply(this, arguments);
}

var sendTransactionsInChunks = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(connection, wallet, instructionSet, signersSet) {
    var sequenceType,
        commitment,
        timeout,
        batchSize,
        instructionsChunk,
        signersChunk,
        _loop,
        c,
        _ret,
        _args5 = arguments;

    return regeneratorRuntime.wrap(function _callee2$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            sequenceType = _args5.length > 4 && _args5[4] !== undefined ? _args5[4] : SequenceType.Parallel;
            commitment = _args5.length > 5 && _args5[5] !== undefined ? _args5[5] : 'singleGossip';
            timeout = _args5.length > 6 && _args5[6] !== undefined ? _args5[6] : 120000;
            batchSize = _args5.length > 7 ? _args5[7] : undefined;

            if (wallet.publicKey) {
              _context5.next = 6;
              break;
            }

            throw new WalletNotConnectedError();

          case 6:
            instructionsChunk = [instructionSet];
            signersChunk = [signersSet];
            instructionsChunk = chunks(instructionSet, batchSize);
            signersChunk = chunks(signersSet, batchSize);
            _loop = /*#__PURE__*/regeneratorRuntime.mark(function _loop(c) {
              var unsignedTxns, _loop2, i, _ret2, signedTxns, breakEarlyObject, _loop3, _i, _ret3;

              return regeneratorRuntime.wrap(function _loop$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      unsignedTxns = [];
                      _loop2 = /*#__PURE__*/regeneratorRuntime.mark(function _loop2(i) {
                        var instructions, signers, transaction, block;
                        return regeneratorRuntime.wrap(function _loop2$(_context2) {
                          while (1) {
                            switch (_context2.prev = _context2.next) {
                              case 0:
                                instructions = instructionsChunk[c][i];
                                signers = signersChunk[c][i];

                                if (!(instructions.length === 0)) {
                                  _context2.next = 4;
                                  break;
                                }

                                return _context2.abrupt("return", "continue");

                              case 4:
                                transaction = new Transaction();
                                _context2.next = 7;
                                return connection.getRecentBlockhash(commitment);

                              case 7:
                                block = _context2.sent;
                                instructions.forEach(function (instruction) {
                                  return transaction.add(instruction);
                                });
                                transaction.recentBlockhash = block.blockhash;
                                transaction.setSigners.apply(transaction, [// fee payed by the wallet owner
                                wallet.publicKey].concat(_toConsumableArray(signers.map(function (s) {
                                  return s.publicKey;
                                }))));

                                if (signers.length > 0) {
                                  transaction.partialSign.apply(transaction, _toConsumableArray(signers));
                                }

                                unsignedTxns.push(transaction);

                              case 13:
                              case "end":
                                return _context2.stop();
                            }
                          }
                        }, _loop2);
                      });
                      i = 0;

                    case 3:
                      if (!(i < instructionsChunk[c].length)) {
                        _context4.next = 11;
                        break;
                      }

                      return _context4.delegateYield(_loop2(i), "t0", 5);

                    case 5:
                      _ret2 = _context4.t0;

                      if (!(_ret2 === "continue")) {
                        _context4.next = 8;
                        break;
                      }

                      return _context4.abrupt("continue", 8);

                    case 8:
                      i++;
                      _context4.next = 3;
                      break;

                    case 11:
                      _context4.next = 13;
                      return wallet.signAllTransactions(unsignedTxns);

                    case 13:
                      signedTxns = _context4.sent;
                      breakEarlyObject = {
                        breakEarly: false,
                        i: 0
                      };
                      console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
                      _loop3 = /*#__PURE__*/regeneratorRuntime.mark(function _loop3(_i) {
                        var signedTxnPromise;
                        return regeneratorRuntime.wrap(function _loop3$(_context3) {
                          while (1) {
                            switch (_context3.prev = _context3.next) {
                              case 0:
                                signedTxnPromise = sendSignedTransaction({
                                  connection: connection,
                                  signedTransaction: signedTxns[_i],
                                  timeout: timeout
                                });
                                signedTxnPromise["catch"](function () {
                                  // @ts-ignore
                                  if (sequenceType === SequenceType.StopOnFailure) {
                                    breakEarlyObject.breakEarly = true;
                                    breakEarlyObject.i = _i;
                                  }
                                });
                                _context3.prev = 2;
                                _context3.next = 5;
                                return signedTxnPromise;

                              case 5:
                                _context3.next = 13;
                                break;

                              case 7:
                                _context3.prev = 7;
                                _context3.t0 = _context3["catch"](2);
                                console.log('Caught failure', _context3.t0);

                                if (!breakEarlyObject.breakEarly) {
                                  _context3.next = 13;
                                  break;
                                }

                                console.log('Died on ', breakEarlyObject.i);
                                return _context3.abrupt("return", {
                                  v: {
                                    v: breakEarlyObject.i
                                  }
                                });

                              case 13:
                              case "end":
                                return _context3.stop();
                            }
                          }
                        }, _loop3, null, [[2, 7]]);
                      });
                      _i = 0;

                    case 18:
                      if (!(_i < signedTxns.length)) {
                        _context4.next = 26;
                        break;
                      }

                      return _context4.delegateYield(_loop3(_i), "t1", 20);

                    case 20:
                      _ret3 = _context4.t1;

                      if (!(_typeof(_ret3) === "object")) {
                        _context4.next = 23;
                        break;
                      }

                      return _context4.abrupt("return", _ret3.v);

                    case 23:
                      _i++;
                      _context4.next = 18;
                      break;

                    case 26:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _loop);
            });
            c = 0;

          case 12:
            if (!(c < instructionsChunk.length)) {
              _context5.next = 20;
              break;
            }

            return _context5.delegateYield(_loop(c), "t0", 14);

          case 14:
            _ret = _context5.t0;

            if (!(_typeof(_ret) === "object")) {
              _context5.next = 17;
              break;
            }

            return _context5.abrupt("return", _ret.v);

          case 17:
            c++;
            _context5.next = 12;
            break;

          case 20:
            return _context5.abrupt("return", instructionSet.length);

          case 21:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee2);
  }));

  return function sendTransactionsInChunks(_x7, _x8, _x9, _x10) {
    return _ref2.apply(this, arguments);
  };
}();
var sendTransactions = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(connection, wallet, instructionSet, signersSet) {
    var sequenceType,
        commitment,
        successCallback,
        failCallback,
        block,
        unsignedTxns,
        _loop4,
        i,
        _ret4,
        signedTxns,
        pendingTxns,
        breakEarlyObject,
        _loop5,
        _i2,
        _ret5,
        _args7 = arguments;

    return regeneratorRuntime.wrap(function _callee3$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            sequenceType = _args7.length > 4 && _args7[4] !== undefined ? _args7[4] : SequenceType.Parallel;
            commitment = _args7.length > 5 && _args7[5] !== undefined ? _args7[5] : 'singleGossip';
            successCallback = _args7.length > 6 && _args7[6] !== undefined ? _args7[6] : function () {};
            failCallback = _args7.length > 7 && _args7[7] !== undefined ? _args7[7] : function () {
              return false;
            };
            block = _args7.length > 8 ? _args7[8] : undefined;

            if (wallet.publicKey) {
              _context7.next = 7;
              break;
            }

            throw new WalletNotConnectedError();

          case 7:
            unsignedTxns = [];

            if (block) {
              _context7.next = 12;
              break;
            }

            _context7.next = 11;
            return connection.getRecentBlockhash(commitment);

          case 11:
            block = _context7.sent;

          case 12:
            _loop4 = function _loop4(i) {
              var instructions = instructionSet[i];
              var signers = signersSet[i];

              if (instructions.length === 0) {
                return "continue";
              }

              var transaction = new Transaction();
              instructions.forEach(function (instruction) {
                return transaction.add(instruction);
              });
              transaction.recentBlockhash = block.blockhash;
              transaction.setSigners.apply(transaction, [// fee payed by the wallet owner
              wallet.publicKey].concat(_toConsumableArray(signers.map(function (s) {
                return s.publicKey;
              }))));

              if (signers.length > 0) {
                transaction.partialSign.apply(transaction, _toConsumableArray(signers));
              }

              unsignedTxns.push(transaction);
            };

            i = 0;

          case 14:
            if (!(i < instructionSet.length)) {
              _context7.next = 21;
              break;
            }

            _ret4 = _loop4(i);

            if (!(_ret4 === "continue")) {
              _context7.next = 18;
              break;
            }

            return _context7.abrupt("continue", 18);

          case 18:
            i++;
            _context7.next = 14;
            break;

          case 21:
            _context7.next = 23;
            return wallet.signAllTransactions(unsignedTxns);

          case 23:
            signedTxns = _context7.sent;
            pendingTxns = [];
            breakEarlyObject = {
              breakEarly: false,
              i: 0
            };
            console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
            _loop5 = /*#__PURE__*/regeneratorRuntime.mark(function _loop5(_i2) {
              var signedTxnPromise;
              return regeneratorRuntime.wrap(function _loop5$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      signedTxnPromise = sendSignedTransaction({
                        connection: connection,
                        signedTransaction: signedTxns[_i2]
                      });
                      signedTxnPromise.then(function (_ref4) {
                        var txid = _ref4.txid;
                        successCallback(txid, _i2);
                      })["catch"](function () {
                        // @ts-ignore
                        failCallback(signedTxns[_i2], _i2);

                        if (sequenceType === SequenceType.StopOnFailure) {
                          breakEarlyObject.breakEarly = true;
                          breakEarlyObject.i = _i2;
                        }
                      });

                      if (!(sequenceType !== SequenceType.Parallel)) {
                        _context6.next = 16;
                        break;
                      }

                      _context6.prev = 3;
                      _context6.next = 6;
                      return signedTxnPromise;

                    case 6:
                      _context6.next = 14;
                      break;

                    case 8:
                      _context6.prev = 8;
                      _context6.t0 = _context6["catch"](3);
                      console.log('Caught failure', _context6.t0);

                      if (!breakEarlyObject.breakEarly) {
                        _context6.next = 14;
                        break;
                      }

                      console.log('Died on ', breakEarlyObject.i);
                      return _context6.abrupt("return", {
                        v: breakEarlyObject.i
                      });

                    case 14:
                      _context6.next = 17;
                      break;

                    case 16:
                      pendingTxns.push(signedTxnPromise);

                    case 17:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _loop5, null, [[3, 8]]);
            });
            _i2 = 0;

          case 29:
            if (!(_i2 < signedTxns.length)) {
              _context7.next = 37;
              break;
            }

            return _context7.delegateYield(_loop5(_i2), "t0", 31);

          case 31:
            _ret5 = _context7.t0;

            if (!(_typeof(_ret5) === "object")) {
              _context7.next = 34;
              break;
            }

            return _context7.abrupt("return", _ret5.v);

          case 34:
            _i2++;
            _context7.next = 29;
            break;

          case 37:
            if (!(sequenceType !== SequenceType.Parallel)) {
              _context7.next = 40;
              break;
            }

            _context7.next = 40;
            return Promise.all(pendingTxns);

          case 40:
            return _context7.abrupt("return", signedTxns.length);

          case 41:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee3);
  }));

  return function sendTransactions(_x11, _x12, _x13, _x14) {
    return _ref3.apply(this, arguments);
  };
}();
var sendTransactionsWithRecentBlock = /*#__PURE__*/function () {
  var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(connection, wallet, instructionSet, signersSet) {
    var commitment,
        unsignedTxns,
        _loop6,
        i,
        _ret6,
        signedTxns,
        breakEarlyObject,
        _loop7,
        _i3,
        _ret7,
        _args10 = arguments;

    return regeneratorRuntime.wrap(function _callee4$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            commitment = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : 'singleGossip';

            if (wallet.publicKey) {
              _context10.next = 3;
              break;
            }

            throw new WalletNotConnectedError();

          case 3:
            unsignedTxns = [];
            _loop6 = /*#__PURE__*/regeneratorRuntime.mark(function _loop6(i) {
              var instructions, signers, block, transaction;
              return regeneratorRuntime.wrap(function _loop6$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      instructions = instructionSet[i];
                      signers = signersSet[i];

                      if (!(instructions.length === 0)) {
                        _context8.next = 4;
                        break;
                      }

                      return _context8.abrupt("return", "continue");

                    case 4:
                      _context8.next = 6;
                      return connection.getRecentBlockhash(commitment);

                    case 6:
                      block = _context8.sent;
                      _context8.next = 9;
                      return sleep(1200);

                    case 9:
                      transaction = new Transaction();
                      instructions.forEach(function (instruction) {
                        return transaction.add(instruction);
                      });
                      transaction.recentBlockhash = block.blockhash;
                      transaction.setSigners.apply(transaction, [// fee payed by the wallet owner
                      wallet.publicKey].concat(_toConsumableArray(signers.map(function (s) {
                        return s.publicKey;
                      }))));

                      if (signers.length > 0) {
                        transaction.partialSign.apply(transaction, _toConsumableArray(signers));
                      }

                      unsignedTxns.push(transaction);

                    case 15:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _loop6);
            });
            i = 0;

          case 6:
            if (!(i < instructionSet.length)) {
              _context10.next = 14;
              break;
            }

            return _context10.delegateYield(_loop6(i), "t0", 8);

          case 8:
            _ret6 = _context10.t0;

            if (!(_ret6 === "continue")) {
              _context10.next = 11;
              break;
            }

            return _context10.abrupt("continue", 11);

          case 11:
            i++;
            _context10.next = 6;
            break;

          case 14:
            _context10.next = 16;
            return wallet.signAllTransactions(unsignedTxns);

          case 16:
            signedTxns = _context10.sent;
            breakEarlyObject = {
              breakEarly: false,
              i: 0
            };
            console.log('Signed txns length', signedTxns.length, 'vs handed in length', instructionSet.length);
            _loop7 = /*#__PURE__*/regeneratorRuntime.mark(function _loop7(_i3) {
              var signedTxnPromise;
              return regeneratorRuntime.wrap(function _loop7$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      signedTxnPromise = sendSignedTransaction({
                        connection: connection,
                        signedTransaction: signedTxns[_i3]
                      });
                      signedTxnPromise["catch"](function () {
                        breakEarlyObject.breakEarly = true;
                        breakEarlyObject.i = _i3;
                      });
                      _context9.prev = 2;
                      _context9.next = 5;
                      return signedTxnPromise;

                    case 5:
                      _context9.next = 13;
                      break;

                    case 7:
                      _context9.prev = 7;
                      _context9.t0 = _context9["catch"](2);
                      console.log('Caught failure', _context9.t0);

                      if (!breakEarlyObject.breakEarly) {
                        _context9.next = 13;
                        break;
                      }

                      console.log('Died on ', breakEarlyObject.i);
                      return _context9.abrupt("return", {
                        v: breakEarlyObject.i
                      });

                    case 13:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _loop7, null, [[2, 7]]);
            });
            _i3 = 0;

          case 21:
            if (!(_i3 < signedTxns.length)) {
              _context10.next = 29;
              break;
            }

            return _context10.delegateYield(_loop7(_i3), "t1", 23);

          case 23:
            _ret7 = _context10.t1;

            if (!(_typeof(_ret7) === "object")) {
              _context10.next = 26;
              break;
            }

            return _context10.abrupt("return", _ret7.v);

          case 26:
            _i3++;
            _context10.next = 21;
            break;

          case 29:
            return _context10.abrupt("return", signedTxns.length);

          case 30:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee4);
  }));

  return function sendTransactionsWithRecentBlock(_x15, _x16, _x17, _x18) {
    return _ref5.apply(this, arguments);
  };
}();
var sendTransaction = /*#__PURE__*/function () {
  var _ref6 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(connection, wallet, instructions, signers) {
    var awaitConfirmation,
        commitment,
        includesFeePayer,
        block,
        transaction,
        _transaction,
        _transaction2,
        _transaction3,
        rawTransaction,
        options,
        txid,
        slot,
        confirmation,
        errors,
        _args11 = arguments;

    return regeneratorRuntime.wrap(function _callee5$(_context11) {
      while (1) {
        switch (_context11.prev = _context11.next) {
          case 0:
            awaitConfirmation = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : true;
            commitment = _args11.length > 5 && _args11[5] !== undefined ? _args11[5] : 'singleGossip';
            includesFeePayer = _args11.length > 6 && _args11[6] !== undefined ? _args11[6] : false;
            block = _args11.length > 7 ? _args11[7] : undefined;

            if (wallet.publicKey) {
              _context11.next = 6;
              break;
            }

            throw new WalletNotConnectedError();

          case 6:
            transaction = new Transaction();
            instructions.forEach(function (instruction) {
              return transaction.add(instruction);
            });
            _context11.t0 = block;

            if (_context11.t0) {
              _context11.next = 13;
              break;
            }

            _context11.next = 12;
            return connection.getRecentBlockhash(commitment);

          case 12:
            _context11.t0 = _context11.sent;

          case 13:
            transaction.recentBlockhash = _context11.t0.blockhash;

            if (includesFeePayer) {
              (_transaction = transaction).setSigners.apply(_transaction, _toConsumableArray(signers.map(function (s) {
                return s.publicKey;
              })));
            } else {
              (_transaction2 = transaction).setSigners.apply(_transaction2, [// fee payed by the wallet owner
              wallet.publicKey].concat(_toConsumableArray(signers.map(function (s) {
                return s.publicKey;
              }))));
            }

            if (signers.length > 0) {
              (_transaction3 = transaction).partialSign.apply(_transaction3, _toConsumableArray(signers));
            }

            if (includesFeePayer) {
              _context11.next = 20;
              break;
            }

            _context11.next = 19;
            return wallet.signTransaction(transaction);

          case 19:
            transaction = _context11.sent;

          case 20:
            rawTransaction = transaction.serialize();
            options = {
              skipPreflight: true,
              commitment: commitment
            };
            _context11.next = 24;
            return connection.sendRawTransaction(rawTransaction, options);

          case 24:
            txid = _context11.sent;
            slot = 0;

            if (!awaitConfirmation) {
              _context11.next = 39;
              break;
            }

            _context11.next = 29;
            return awaitTransactionSignatureConfirmation(txid, DEFAULT_TIMEOUT, connection, commitment);

          case 29:
            confirmation = _context11.sent;

            if (confirmation) {
              _context11.next = 32;
              break;
            }

            throw new Error('Timed out awaiting confirmation on transaction');

          case 32:
            slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;

            if (!(confirmation !== null && confirmation !== void 0 && confirmation.err)) {
              _context11.next = 39;
              break;
            }

            _context11.next = 36;
            return getErrorForTransaction(connection, txid);

          case 36:
            errors = _context11.sent;
            console.error(errors);
            throw new Error("Raw transaction ".concat(txid, " failed (").concat(JSON.stringify(status), ")"));

          case 39:
            return _context11.abrupt("return", {
              txid: txid,
              slot: slot
            });

          case 40:
          case "end":
            return _context11.stop();
        }
      }
    }, _callee5);
  }));

  return function sendTransaction(_x19, _x20, _x21, _x22) {
    return _ref6.apply(this, arguments);
  };
}();
var sendTransactionWithRetry = /*#__PURE__*/function () {
  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(connection, wallet, instructions, signers) {
    var commitment,
        includesFeePayer,
        block,
        beforeSend,
        transaction,
        _transaction4,
        _transaction5,
        _transaction6,
        _yield$sendSignedTran,
        txid,
        slot,
        _args12 = arguments;

    return regeneratorRuntime.wrap(function _callee6$(_context12) {
      while (1) {
        switch (_context12.prev = _context12.next) {
          case 0:
            commitment = _args12.length > 4 && _args12[4] !== undefined ? _args12[4] : 'singleGossip';
            includesFeePayer = _args12.length > 5 && _args12[5] !== undefined ? _args12[5] : false;
            block = _args12.length > 6 ? _args12[6] : undefined;
            beforeSend = _args12.length > 7 ? _args12[7] : undefined;

            if (wallet.publicKey) {
              _context12.next = 6;
              break;
            }

            throw new WalletNotConnectedError();

          case 6:
            transaction = new Transaction();
            instructions.forEach(function (instruction) {
              return transaction.add(instruction);
            });
            _context12.t0 = block;

            if (_context12.t0) {
              _context12.next = 13;
              break;
            }

            _context12.next = 12;
            return connection.getRecentBlockhash(commitment);

          case 12:
            _context12.t0 = _context12.sent;

          case 13:
            transaction.recentBlockhash = _context12.t0.blockhash;

            if (includesFeePayer) {
              (_transaction4 = transaction).setSigners.apply(_transaction4, _toConsumableArray(signers.map(function (s) {
                return s.publicKey;
              })));
            } else {
              (_transaction5 = transaction).setSigners.apply(_transaction5, [// fee payed by the wallet owner
              wallet.publicKey].concat(_toConsumableArray(signers.map(function (s) {
                return s.publicKey;
              }))));
            }

            if (signers.length > 0) {
              (_transaction6 = transaction).partialSign.apply(_transaction6, _toConsumableArray(signers));
            }

            if (includesFeePayer) {
              _context12.next = 20;
              break;
            }

            _context12.next = 19;
            return wallet.signTransaction(transaction);

          case 19:
            transaction = _context12.sent;

          case 20:
            if (beforeSend) {
              beforeSend();
            }

            _context12.next = 23;
            return sendSignedTransaction({
              connection: connection,
              signedTransaction: transaction
            });

          case 23:
            _yield$sendSignedTran = _context12.sent;
            txid = _yield$sendSignedTran.txid;
            slot = _yield$sendSignedTran.slot;
            return _context12.abrupt("return", {
              txid: txid,
              slot: slot
            });

          case 27:
          case "end":
            return _context12.stop();
        }
      }
    }, _callee6);
  }));

  return function sendTransactionWithRetry(_x23, _x24, _x25, _x26) {
    return _ref7.apply(this, arguments);
  };
}();
var getUnixTs = function getUnixTs() {
  return new Date().getTime() / 1000;
};
var DEFAULT_TIMEOUT = 15000;
function sendSignedTransaction(_x27) {
  return _sendSignedTransaction.apply(this, arguments);
}

function _sendSignedTransaction() {
  _sendSignedTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(_ref8) {
    var signedTransaction, connection, _ref8$timeout, timeout, rawTransaction, startTime, slot, txid, done, confirmation, simulateResult, i, line;

    return regeneratorRuntime.wrap(function _callee9$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            signedTransaction = _ref8.signedTransaction, connection = _ref8.connection, _ref8$timeout = _ref8.timeout, timeout = _ref8$timeout === void 0 ? DEFAULT_TIMEOUT : _ref8$timeout;
            rawTransaction = signedTransaction.serialize();
            startTime = getUnixTs();
            slot = 0;
            _context15.next = 6;
            return connection.sendRawTransaction(rawTransaction, {
              skipPreflight: true
            });

          case 6:
            txid = _context15.sent;
            console.log('Started awaiting confirmation for', txid);
            done = false;

            _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
              return regeneratorRuntime.wrap(function _callee8$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      if (!(!done && getUnixTs() - startTime < timeout)) {
                        _context14.next = 6;
                        break;
                      }

                      connection.sendRawTransaction(rawTransaction, {
                        skipPreflight: true
                      });
                      _context14.next = 4;
                      return sleep(500);

                    case 4:
                      _context14.next = 0;
                      break;

                    case 6:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee8);
            }))();

            _context15.prev = 10;
            _context15.next = 13;
            return awaitTransactionSignatureConfirmation(txid, timeout, connection, 'recent', true);

          case 13:
            confirmation = _context15.sent;

            if (confirmation) {
              _context15.next = 16;
              break;
            }

            throw new Error('Timed out awaiting confirmation on transaction');

          case 16:
            if (!confirmation.err) {
              _context15.next = 19;
              break;
            }

            console.error(confirmation.err);
            throw new Error('Transaction failed: Custom instruction error');

          case 19:
            slot = (confirmation === null || confirmation === void 0 ? void 0 : confirmation.slot) || 0;
            _context15.next = 47;
            break;

          case 22:
            _context15.prev = 22;
            _context15.t0 = _context15["catch"](10);
            console.error('Timeout Error caught', _context15.t0);

            if (!_context15.t0.timeout) {
              _context15.next = 27;
              break;
            }

            throw new Error('Timed out awaiting confirmation on transaction');

          case 27:
            simulateResult = null;
            _context15.prev = 28;
            _context15.next = 31;
            return simulateTransaction(connection, signedTransaction, 'single');

          case 31:
            simulateResult = _context15.sent.value;
            _context15.next = 36;
            break;

          case 34:
            _context15.prev = 34;
            _context15.t1 = _context15["catch"](28);

          case 36:
            if (!(simulateResult && simulateResult.err)) {
              _context15.next = 47;
              break;
            }

            if (!simulateResult.logs) {
              _context15.next = 46;
              break;
            }

            i = simulateResult.logs.length - 1;

          case 39:
            if (!(i >= 0)) {
              _context15.next = 46;
              break;
            }

            line = simulateResult.logs[i];

            if (!line.startsWith('Program log: ')) {
              _context15.next = 43;
              break;
            }

            throw new Error('Transaction failed: ' + line.slice('Program log: '.length));

          case 43:
            --i;
            _context15.next = 39;
            break;

          case 46:
            throw new Error(JSON.stringify(simulateResult.err));

          case 47:
            _context15.prev = 47;
            done = true;
            return _context15.finish(47);

          case 50:
            console.log('Latency', txid, getUnixTs() - startTime);
            return _context15.abrupt("return", {
              txid: txid,
              slot: slot
            });

          case 52:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee9, null, [[10, 22, 47, 50], [28, 34]]);
  }));
  return _sendSignedTransaction.apply(this, arguments);
}

function simulateTransaction(_x28, _x29, _x30) {
  return _simulateTransaction.apply(this, arguments);
}

function _simulateTransaction() {
  _simulateTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(connection, transaction, commitment) {
    var signData, wireTransaction, encodedTransaction, config, args, res;
    return regeneratorRuntime.wrap(function _callee10$(_context16) {
      while (1) {
        switch (_context16.prev = _context16.next) {
          case 0:
            _context16.next = 2;
            return connection._recentBlockhash( // @ts-ignore
            connection._disableBlockhashCaching);

          case 2:
            transaction.recentBlockhash = _context16.sent;
            signData = transaction.serializeMessage(); // @ts-ignore

            wireTransaction = transaction._serialize(signData);
            encodedTransaction = wireTransaction.toString('base64');
            config = {
              encoding: 'base64',
              commitment: commitment
            };
            args = [encodedTransaction, config]; // @ts-ignore

            _context16.next = 10;
            return connection._rpcRequest('simulateTransaction', args);

          case 10:
            res = _context16.sent;

            if (!res.error) {
              _context16.next = 13;
              break;
            }

            throw new Error('failed to simulate transaction: ' + res.error.message);

          case 13:
            return _context16.abrupt("return", res.result);

          case 14:
          case "end":
            return _context16.stop();
        }
      }
    }, _callee10);
  }));
  return _simulateTransaction.apply(this, arguments);
}

function awaitTransactionSignatureConfirmation(_x31, _x32, _x33) {
  return _awaitTransactionSignatureConfirmation.apply(this, arguments);
}

function _awaitTransactionSignatureConfirmation() {
  _awaitTransactionSignatureConfirmation = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(txid, timeout, connection) {
    var commitment,
        queryStatus,
        done,
        status,
        subId,
        _args18 = arguments;
    return regeneratorRuntime.wrap(function _callee12$(_context18) {
      while (1) {
        switch (_context18.prev = _context18.next) {
          case 0:
            commitment = _args18.length > 3 && _args18[3] !== undefined ? _args18[3] : 'recent';
            queryStatus = _args18.length > 4 && _args18[4] !== undefined ? _args18[4] : false;
            done = false;
            status = {
              slot: 0,
              confirmations: 0,
              err: null
            };
            subId = 0;
            _context18.next = 7;
            return _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11() {
              var signatureStatuses, nextStatus;
              return regeneratorRuntime.wrap(function _callee11$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      setTimeout(function () {
                        if (done) {
                          return;
                        }

                        done = true;
                        console.log('Rejecting for timeout...');
                        throw {
                          timeout: true
                        };
                      }, timeout);
                      _context17.prev = 1;
                      _context17.next = 4;
                      return new Promise(function (resolve, reject) {
                        subId = connection.onSignature(txid, function (result, context) {
                          done = true;
                          var nextStatus = {
                            err: result.err,
                            slot: context.slot,
                            confirmations: 0
                          };

                          if (result.err) {
                            console.log('Rejected via websocket', result.err);
                            reject(nextStatus);
                          } else {
                            console.log('Resolved via websocket', result);
                            resolve(nextStatus);
                          }
                        }, commitment);
                      });

                    case 4:
                      return _context17.abrupt("return", _context17.sent);

                    case 7:
                      _context17.prev = 7;
                      _context17.t0 = _context17["catch"](1);
                      done = true;
                      console.error('WS error in setup', txid, _context17.t0);

                    case 11:
                      if (!(!done && queryStatus)) {
                        _context17.next = 44;
                        break;
                      }

                      _context17.prev = 12;
                      _context17.next = 15;
                      return connection.getSignatureStatuses([txid]);

                    case 15:
                      signatureStatuses = _context17.sent;
                      nextStatus = signatureStatuses && signatureStatuses.value[0];

                      if (done) {
                        _context17.next = 35;
                        break;
                      }

                      if (nextStatus) {
                        _context17.next = 22;
                        break;
                      }

                      console.log('REST null result for', txid, nextStatus);
                      _context17.next = 35;
                      break;

                    case 22:
                      if (!nextStatus.err) {
                        _context17.next = 28;
                        break;
                      }

                      console.log('REST error for', txid, nextStatus);
                      done = true;
                      throw nextStatus.err;

                    case 28:
                      if (nextStatus.confirmations) {
                        _context17.next = 32;
                        break;
                      }

                      console.log('REST no confirmations for', txid, nextStatus);
                      _context17.next = 35;
                      break;

                    case 32:
                      console.log('REST confirmation for', txid, nextStatus);
                      done = true;
                      return _context17.abrupt("return", nextStatus);

                    case 35:
                      _context17.next = 40;
                      break;

                    case 37:
                      _context17.prev = 37;
                      _context17.t1 = _context17["catch"](12);

                      if (!done) {
                        console.log('REST connection error: txid', txid, _context17.t1);
                      }

                    case 40:
                      _context17.next = 42;
                      return sleep(2000);

                    case 42:
                      _context17.next = 11;
                      break;

                    case 44:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee11, null, [[1, 7], [12, 37]]);
            }))();

          case 7:
            status = _context18.sent;
            //@ts-ignore
            if (connection._signatureSubscriptions[subId]) connection.removeSignatureListener(subId);
            done = true;
            console.log('Returning status', status);
            return _context18.abrupt("return", status);

          case 12:
          case "end":
            return _context18.stop();
        }
      }
    }, _callee12);
  }));
  return _awaitTransactionSignatureConfirmation.apply(this, arguments);
}

function chunks(array, size) {
  // @ts-ignore
  return Array.apply(0, new Array(Math.ceil(array.length / size))).map(function (_, index) {
    return array.slice(index * size, (index + 1) * size);
  });
}
function sleep(ms) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, ms);
  });
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

var InsufficientBalanceError = /*#__PURE__*/function (_Error) {
  _inherits(InsufficientBalanceError, _Error);

  var _super = _createSuper(InsufficientBalanceError);

  function InsufficientBalanceError(message) {
    var _this;

    _classCallCheck(this, InsufficientBalanceError);

    _this = _super.call(this, message);
    _this.message = 'Insufficient Balance for transaction';
    _this.name = 'InsufficientBalanceError';
    return _this;
  }

  return InsufficientBalanceError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var ListingAlreadyExistsError = /*#__PURE__*/function (_Error2) {
  _inherits(ListingAlreadyExistsError, _Error2);

  var _super2 = _createSuper(ListingAlreadyExistsError);

  function ListingAlreadyExistsError(message) {
    var _this2;

    _classCallCheck(this, ListingAlreadyExistsError);

    _this2 = _super2.call(this, message);
    _this2.message = "You cannot update a token's listing to the same price. Please update listing to a different price";
    _this2.name = 'ListingAlreadyExistsError';
    return _this2;
  }

  return ListingAlreadyExistsError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
function programErrorHandler(error) {
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  // Is on-chain error
  var errorLogs = error.logs;

  if (errorLogs) {
    var anchorErrorMessageIndex = error.logs.findIndex(function (log) {
      return log.includes('AnchorError');
    });

    var errorLogsCopy = _construct(Array, _toConsumableArray(errorLogs));

    var anchorErrorMessage = errorLogsCopy.splice(0, anchorErrorMessageIndex + 1).find(function (log) {
      return log.includes('Instruction:');
    });
    console.log({
      anchorErrorMessage: anchorErrorMessage
    });

    if (anchorErrorMessage) {
      var errorMessage = errorLogs[anchorErrorMessageIndex];
      var message = errorMessage.includes('DerivedKeyInvalid') ? "Invalid parameters passed into transaction. Please make sure you passed the correct ".concat(action, " parameters. More information: ").concat(errorMessage, ".") : errorMessage;

      var _error = new Error(anchorErrorMessage + ' ' + message);

      throw _error;
    } else {
      throw new Error(error.msg);
    }
  } else {
    throw error;
  }
}

var prepareTokenAccountAndMintTxs = actions.prepareTokenAccountAndMintTxs;
var _programs$metadata = programs.metadata,
    Metadata$1 = _programs$metadata.Metadata,
    MasterEdition = _programs$metadata.MasterEdition,
    MetadataDataData = _programs$metadata.MetadataDataData,
    CreateMasterEdition = _programs$metadata.CreateMasterEdition,
    CreateMetadata = _programs$metadata.CreateMetadata,
    Creator$2 = _programs$metadata.Creator,
    UpdateMetadata = _programs$metadata.UpdateMetadata;

var lookup = function lookup(url) {
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var res, data;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.prev = 0;
            _context.next = 3;
            return fetch(url);

          case 3:
            res = _context.sent;
            _context.next = 6;
            return res.json();

          case 6:
            data = _context.sent;
            return _context.abrupt("return", data);

          case 10:
            _context.prev = 10;
            _context.t0 = _context["catch"](0);
            throw new Error("unable to get metadata json from url ".concat(url));

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[0, 10]]);
  }));
};

var mintNFT = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(_ref2) {
    var connection, wallet, uri, maxSupply, updateAuthority, _yield$prepareTokenAc, mint, createMintTx, createAssociatedTokenAccountTx, mintToTx, _retryLookupFunction, metadataPDA, editionPDA, lookupResult, name, symbol, seller_fee_basis_points, creators, creatorsData, metadataData, createMetadataTx, masterEditionTx, updateMetaDataTx, txt, estimatedCost, _yield$connection$get, _balance, balance, signed, signature, result;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            connection = _ref2.connection, wallet = _ref2.wallet, uri = _ref2.uri, maxSupply = _ref2.maxSupply, updateAuthority = _ref2.updateAuthority;
            _context2.next = 3;
            return prepareTokenAccountAndMintTxs(connection, wallet.publicKey);

          case 3:
            _yield$prepareTokenAc = _context2.sent;
            mint = _yield$prepareTokenAc.mint;
            createMintTx = _yield$prepareTokenAc.createMintTx;
            createAssociatedTokenAccountTx = _yield$prepareTokenAc.createAssociatedTokenAccountTx;
            mintToTx = _yield$prepareTokenAc.mintToTx;
            // Sometimes reading new assets from nft.storage slow
            _retryLookupFunction = retryUntil(40000);
            _context2.next = 11;
            return Metadata$1.getPDA(mint.publicKey);

          case 11:
            metadataPDA = _context2.sent;
            _context2.next = 14;
            return MasterEdition.getPDA(mint.publicKey);

          case 14:
            editionPDA = _context2.sent;
            _context2.next = 17;
            return sleep(3000);

          case 17:
            _context2.next = 19;
            return _retryLookupFunction(lookup(uri));

          case 19:
            lookupResult = _context2.sent;
            name = lookupResult.name, symbol = lookupResult.symbol, seller_fee_basis_points = lookupResult.seller_fee_basis_points, creators = lookupResult.properties.creators;
            creatorsData = creators.reduce(function (memo, _ref4) {
              var address = _ref4.address,
                  share = _ref4.share;
              var verified = address === wallet.publicKey.toString();
              var creator = new Creator$2({
                address: address,
                share: share,
                verified: verified
              });
              memo = [].concat(_toConsumableArray(memo), [creator]);
              return memo; // @ts-ignore
            }, []);
            metadataData = new MetadataDataData({
              name: name,
              symbol: symbol,
              uri: uri,
              sellerFeeBasisPoints: seller_fee_basis_points,
              creators: creatorsData
            });
            createMetadataTx = new CreateMetadata({
              feePayer: wallet.publicKey
            }, {
              metadata: metadataPDA,
              metadataData: metadataData,
              updateAuthority: wallet.publicKey,
              mint: mint.publicKey,
              mintAuthority: wallet.publicKey
            });
            masterEditionTx = new CreateMasterEdition({
              feePayer: wallet.publicKey
            }, {
              edition: editionPDA,
              metadata: metadataPDA,
              updateAuthority: wallet.publicKey,
              mint: mint.publicKey,
              mintAuthority: wallet.publicKey,
              maxSupply: maxSupply || maxSupply === 0 ? new BN(maxSupply) : undefined
            });
            updateMetaDataTx = new UpdateMetadata({
              feePayer: wallet.publicKey
            }, {
              metadata: metadataPDA,
              updateAuthority: wallet.publicKey,
              newUpdateAuthority: updateAuthority
            });
            txt = new Transaction$1();
            txt.add(createMintTx).add(createMetadataTx).add(createAssociatedTokenAccountTx).add(mintToTx).add(masterEditionTx).add(updateMetaDataTx);
            _context2.next = 30;
            return connection.getRecentBlockhash();

          case 30:
            txt.recentBlockhash = _context2.sent.blockhash;
            txt.feePayer = wallet.publicKey;
            _context2.next = 34;
            return txt.getEstimatedFee(connection);

          case 34:
            _context2.t0 = _context2.sent;
            _context2.t1 = LAMPORTS_PER_SOL;
            estimatedCost = _context2.t0 / _context2.t1;
            _context2.next = 39;
            return connection.getBalanceAndContext(wallet.publicKey);

          case 39:
            _yield$connection$get = _context2.sent;
            _balance = _yield$connection$get.value;
            balance = _balance / LAMPORTS_PER_SOL;
            console.log('Estimated cost of transaction: ', estimatedCost);
            console.log('Wallet Balance', balance, '');

            if (!(balance < estimatedCost)) {
              _context2.next = 46;
              break;
            }

            throw new InsufficientBalanceError('Account balance is not enough to complete transaction');

          case 46:
            signed = undefined;
            _context2.prev = 47;
            _context2.next = 50;
            return txt.partialSign.apply(txt, [mint]);

          case 50:
            _context2.next = 52;
            return wallet.signTransaction(txt);

          case 52:
            signed = _context2.sent;
            _context2.next = 59;
            break;

          case 55:
            _context2.prev = 55;
            _context2.t2 = _context2["catch"](47);
            console.error(_context2.t2.message);
            throw _context2.t2;

          case 59:
            signature = undefined;
            _context2.next = 62;
            return connection.sendRawTransaction(signed.serialize());

          case 62:
            signature = _context2.sent;
            _context2.next = 65;
            return connection.confirmTransaction(signature, 'confirmed');

          case 65:
            result = _context2.sent;
            return _context2.abrupt("return", {
              transaction: result,
              mint: mint.publicKey,
              metadata: metadataPDA,
              edition: editionPDA
            });

          case 67:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[47, 55]]);
  }));

  return function mintNFT(_x) {
    return _ref3.apply(this, arguments);
  };
}();

var isFunction = function isFunction(f) {
  return typeof f === 'function';
};

var retryUntil = function retryUntil(duration) {
  return function (fn) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var threw = true;
    var start = Date.now();

    var catcher = function catcher(er) {
      var left = duration + start - Date.now();
      if (left > 0) return retryUntil(left).apply(void 0, [fn].concat(args));else throw er;
    };

    while (true) {
      try {
        var ret = fn.apply(void 0, args);
        threw = false;
        return ret && isFunction(ret.then) && isFunction(ret["catch"]) ? ret["catch"](catcher) : ret;
      } finally {
        if (threw && Date.now() - start < duration) continue;
      }
    }
  };
};

/**
 * Create Cancel Listing Transaction
 * @param mint
 * @param currentListingPrice
 * @param sellerPublicKey
 * @param auctionHouse
 * @param connection
 * @param auctionHouseAuthority
 * @param program
 * @param __DANGEROUSLY_INSET_SELLER__
 */

function createCancelListingTransaction(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
  return _createCancelListingTransaction.apply(this, arguments);
}

function _createCancelListingTransaction() {
  _createCancelListingTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mint, currentListingPrice, sellerPublicKey, auctionHouse, program, auctionHouseAuthority, connection, __DANGEROUSLY_INSET_SELLER__) {
    var buyerPrice, _mint, _yield$getNftOwner, _yield$getNftOwner2, sellerAddressAsString, _sellerPublicKey, auctionHouseObj, sellerTradeState, associatedTokenAccount, DANGEROUS_SELLER, _yield$getAtaForMint, _yield$getAtaForMint2, _yield$AuctionHousePr, _yield$AuctionHousePr2, _yield$getAtaForMint3, _yield$getAtaForMint4, _yield$AuctionHousePr3, _yield$AuctionHousePr4, _yield$AuctionHousePr5, _yield$AuctionHousePr6, listingReceipt, authority, auctionHouseFeeAccount, receipt, cancelInstructionAccounts, cancelInstructionArgs, cancelListingReceiptAccounts, cancelInstruction, cancelListingReceiptInstruction, transaction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            buyerPrice = Number(currentListingPrice) * LAMPORTS_PER_SOL;
            _mint = new PublicKey(mint);
            _context.next = 4;
            return getNftOwner(_mint, connection);

          case 4:
            _yield$getNftOwner = _context.sent;
            _yield$getNftOwner2 = _slicedToArray(_yield$getNftOwner, 2);
            sellerAddressAsString = _yield$getNftOwner2[0];
            _sellerPublicKey = _yield$getNftOwner2[1];

            if (!(sellerPublicKey.toBase58() !== sellerAddressAsString)) {
              _context.next = 10;
              break;
            }

            throw new Error('You cannot cancel listing of an NFT you do not own.');

          case 10:
            _context.next = 12;
            return program.account.auctionHouse.fetch(auctionHouse);

          case 12:
            auctionHouseObj = _context.sent;

            if (!__DANGEROUSLY_INSET_SELLER__) {
              _context.next = 28;
              break;
            }

            console.warn('DANGEROUSLY INSETTING SELLER', __DANGEROUSLY_INSET_SELLER__); // Only for manual cancellations of listings by the
            // auctionhouse authority
            // !!! DANGEROUS !!! This action should only be performed by the auctionhouse authority

            DANGEROUS_SELLER = new PublicKey(__DANGEROUSLY_INSET_SELLER__);
            _context.next = 18;
            return getAtaForMint(_mint, DANGEROUS_SELLER);

          case 18:
            _yield$getAtaForMint = _context.sent;
            _yield$getAtaForMint2 = _slicedToArray(_yield$getAtaForMint, 1);
            associatedTokenAccount = _yield$getAtaForMint2[0];
            _context.next = 23;
            return AuctionHouseProgram.findTradeStateAddress(DANGEROUS_SELLER, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, buyerPrice, 1);

          case 23:
            _yield$AuctionHousePr = _context.sent;
            _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 1);
            sellerTradeState = _yield$AuctionHousePr2[0];
            _context.next = 39;
            break;

          case 28:
            console.log('Processing cancel listing');
            _context.next = 31;
            return getAtaForMint(_mint, _sellerPublicKey);

          case 31:
            _yield$getAtaForMint3 = _context.sent;
            _yield$getAtaForMint4 = _slicedToArray(_yield$getAtaForMint3, 1);
            associatedTokenAccount = _yield$getAtaForMint4[0];
            _context.next = 36;
            return AuctionHouseProgram.findTradeStateAddress(_sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, buyerPrice, 1);

          case 36:
            _yield$AuctionHousePr3 = _context.sent;
            _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 1);
            sellerTradeState = _yield$AuctionHousePr4[0];

          case 39:
            _context.next = 41;
            return AuctionHouseProgram.findListingReceiptAddress(sellerTradeState);

          case 41:
            _yield$AuctionHousePr5 = _context.sent;
            _yield$AuctionHousePr6 = _slicedToArray(_yield$AuctionHousePr5, 1);
            listingReceipt = _yield$AuctionHousePr6[0];
            authority = auctionHouseAuthority;
            auctionHouseFeeAccount = new PublicKey(auctionHouseObj.auctionHouseFeeAccount);
            receipt = listingReceipt;
            cancelInstructionAccounts = {
              wallet: __DANGEROUSLY_INSET_SELLER__ ? new PublicKey(__DANGEROUSLY_INSET_SELLER__) : sellerPublicKey,
              tokenAccount: associatedTokenAccount,
              tokenMint: _mint,
              authority: authority,
              auctionHouse: auctionHouse,
              auctionHouseFeeAccount: auctionHouseFeeAccount,
              tradeState: sellerTradeState
            };
            cancelInstructionArgs = {
              buyerPrice: buyerPrice,
              tokenSize: 1
            };
            cancelListingReceiptAccounts = {
              receipt: receipt,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            };
            _context.next = 52;
            return createCancelInstruction(cancelInstructionAccounts, cancelInstructionArgs);

          case 52:
            cancelInstruction = _context.sent;
            cancelListingReceiptInstruction = createCancelListingReceiptInstruction(cancelListingReceiptAccounts);
            transaction = new Transaction();
            transaction.add(cancelInstruction).add(cancelListingReceiptInstruction);
            return _context.abrupt("return", [transaction, receipt]);

          case 57:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createCancelListingTransaction.apply(this, arguments);
}

var _AuctionHouseProgram$$1 = AuctionHouseProgram.instructions,
    createPrintListingReceiptInstruction = _AuctionHouseProgram$$1.createPrintListingReceiptInstruction,
    createSellInstruction = _AuctionHouseProgram$$1.createSellInstruction;
/**
 * Create List Transaction
 * @param mint
 * @param listingPrice
 * @param sellerPublicKey
 * @param auctionHouse
 * @param program
 */

function createListingTransaction(_x, _x2, _x3, _x4, _x5) {
  return _createListingTransaction.apply(this, arguments);
}

function _createListingTransaction() {
  _createListingTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mint, listingPrice, sellerPublicKey, auctionHouse, program) {
    var _listingPrice, tokenSize, auctionHouseObj, nftMetadataAccount, _yield$getAtaForMint, _yield$getAtaForMint2, associatedTokenAccount, _yield$AuctionHousePr, _yield$AuctionHousePr2, sellerTradeState, tradeStateBump, _yield$AuctionHousePr3, _yield$AuctionHousePr4, freeTradeState, freeTradeBump, _yield$AuctionHousePr5, _yield$AuctionHousePr6, receipt, receiptBump, _yield$AuctionHousePr7, _yield$AuctionHousePr8, programAsSigner, programAsSignerBump, sellInstructionAccounts, sellInstructionArgs, sellInstruction, printListingReceiptInstructionAccounts, printListingReceiptInstructionArgs, printListingReceiptInstruction, transaction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _listingPrice = Number(listingPrice) * LAMPORTS_PER_SOL;
            tokenSize = 1;
            _context.next = 4;
            return program.account.auctionHouse.fetch(auctionHouse);

          case 4:
            auctionHouseObj = _context.sent;
            _context.next = 7;
            return getMetadata(mint);

          case 7:
            nftMetadataAccount = _context.sent;
            _context.next = 10;
            return getAtaForMint(mint, sellerPublicKey);

          case 10:
            _yield$getAtaForMint = _context.sent;
            _yield$getAtaForMint2 = _slicedToArray(_yield$getAtaForMint, 1);
            associatedTokenAccount = _yield$getAtaForMint2[0];
            _context.next = 15;
            return AuctionHouseProgram.findTradeStateAddress(sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, mint, _listingPrice, 1);

          case 15:
            _yield$AuctionHousePr = _context.sent;
            _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 2);
            sellerTradeState = _yield$AuctionHousePr2[0];
            tradeStateBump = _yield$AuctionHousePr2[1];
            _context.next = 21;
            return AuctionHouseProgram.findTradeStateAddress(sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, mint, 0, 1);

          case 21:
            _yield$AuctionHousePr3 = _context.sent;
            _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 2);
            freeTradeState = _yield$AuctionHousePr4[0];
            freeTradeBump = _yield$AuctionHousePr4[1];
            _context.next = 27;
            return AuctionHouseProgram.findListingReceiptAddress(sellerTradeState);

          case 27:
            _yield$AuctionHousePr5 = _context.sent;
            _yield$AuctionHousePr6 = _slicedToArray(_yield$AuctionHousePr5, 2);
            receipt = _yield$AuctionHousePr6[0];
            receiptBump = _yield$AuctionHousePr6[1];
            console.debug('[sellerTradeState, receipt]', [sellerTradeState.toBase58(), receipt.toBase58()]);
            _context.next = 34;
            return AuctionHouseProgram.findAuctionHouseProgramAsSignerAddress();

          case 34:
            _yield$AuctionHousePr7 = _context.sent;
            _yield$AuctionHousePr8 = _slicedToArray(_yield$AuctionHousePr7, 2);
            programAsSigner = _yield$AuctionHousePr8[0];
            programAsSignerBump = _yield$AuctionHousePr8[1];
            sellInstructionAccounts = {
              auctionHouse: auctionHouse,
              auctionHouseFeeAccount: new PublicKey(auctionHouseObj.auctionHouseFeeAccount),
              authority: new PublicKey(auctionHouseObj.authority),
              wallet: sellerPublicKey,
              metadata: nftMetadataAccount,
              tokenAccount: associatedTokenAccount,
              freeSellerTradeState: freeTradeState,
              sellerTradeState: sellerTradeState,
              programAsSigner: programAsSigner
            };
            sellInstructionArgs = {
              buyerPrice: listingPrice,
              freeTradeStateBump: freeTradeBump,
              tradeStateBump: tradeStateBump,
              programAsSignerBump: programAsSignerBump,
              tokenSize: tokenSize
            };
            _context.next = 42;
            return createSellInstruction(sellInstructionAccounts, sellInstructionArgs);

          case 42:
            sellInstruction = _context.sent;
            printListingReceiptInstructionAccounts = {
              receipt: receipt,
              bookkeeper: sellerPublicKey,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            };
            printListingReceiptInstructionArgs = {
              receiptBump: receiptBump
            };
            printListingReceiptInstruction = createPrintListingReceiptInstruction(printListingReceiptInstructionAccounts, printListingReceiptInstructionArgs);
            transaction = new Transaction();
            transaction.add(sellInstruction).add(printListingReceiptInstruction);
            return _context.abrupt("return", [transaction, receipt]);

          case 49:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createListingTransaction.apply(this, arguments);
}

/**
 * Create Update Listing Transaction
 * @param mint
 * @param currentListingPrice
 * @param newListingPrice
 * @param sellerPublicKey
 * @param auctionHouse
 * @param connection
 * @param auctionHouseAuthority
 * @param program
 */

function createUpdateListingTransaction(_x, _x2, _x3, _x4, _x5, _x6, _x7, _x8) {
  return _createUpdateListingTransaction.apply(this, arguments);
}

function _createUpdateListingTransaction() {
  _createUpdateListingTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mint, currentListingPrice, newListingPrice, sellerPublicKey, auctionHouse, program, auctionHouseAuthority, connection) {
    var _currentListingPrice, _newListingPrice, _mint, _yield$getNftOwner, _yield$getNftOwner2, sellerAddressAsString, _sellerPublicKey, auctionHouseObj, _yield$AuctionHousePr, _yield$AuctionHousePr2, programAsSigner, programAsSignerBump, _yield$getAtaForMint, _yield$getAtaForMint2, associatedTokenAccount, _yield$AuctionHousePr3, _yield$AuctionHousePr4, sellerTradeState, _yield$AuctionHousePr5, _yield$AuctionHousePr6, listingReceipt, authority, auctionHouseFeeAccount, receipt, cancelInstructionAccounts, cancelInstructionArgs, cancelListingReceiptAccounts, listingPrice, nftMetadataAccount, _yield$AuctionHousePr7, _yield$AuctionHousePr8, newSellerTradeState, newTradeStateBump, _yield$AuctionHousePr9, _yield$AuctionHousePr10, newFreeTradeState, newFreeTradeBump, _yield$AuctionHousePr11, _yield$AuctionHousePr12, newListingReceipt, newListingReceiptBump, sellInstructionAccounts, sellInstructionArgs, printListingReceiptInstructionAccounts, printListingReceiptInstructionArgs, cancelInstruction, cancelListingReceiptInstruction, sellInstruction, printListingReceiptInstruction, transaction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _currentListingPrice = Number(currentListingPrice) * LAMPORTS_PER_SOL;
            _newListingPrice = Number(newListingPrice) * LAMPORTS_PER_SOL;
            _mint = new PublicKey(mint);
            _context.next = 5;
            return getNftOwner(_mint, connection);

          case 5:
            _yield$getNftOwner = _context.sent;
            _yield$getNftOwner2 = _slicedToArray(_yield$getNftOwner, 2);
            sellerAddressAsString = _yield$getNftOwner2[0];
            _sellerPublicKey = _yield$getNftOwner2[1];

            if (!(sellerPublicKey.toBase58() !== sellerAddressAsString && sellerPublicKey.toBase58() !== auctionHouseAuthority.toBase58())) {
              _context.next = 11;
              break;
            }

            throw new Error('You cannot cancel listing of an NFT you do not own.');

          case 11:
            _context.next = 13;
            return program.account.auctionHouse.fetch(auctionHouse);

          case 13:
            auctionHouseObj = _context.sent;
            _context.next = 16;
            return AuctionHouseProgram.findAuctionHouseProgramAsSignerAddress();

          case 16:
            _yield$AuctionHousePr = _context.sent;
            _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 2);
            programAsSigner = _yield$AuctionHousePr2[0];
            programAsSignerBump = _yield$AuctionHousePr2[1];
            _context.next = 22;
            return getAtaForMint(_mint, _sellerPublicKey);

          case 22:
            _yield$getAtaForMint = _context.sent;
            _yield$getAtaForMint2 = _slicedToArray(_yield$getAtaForMint, 1);
            associatedTokenAccount = _yield$getAtaForMint2[0];
            _context.next = 27;
            return AuctionHouseProgram.findTradeStateAddress(_sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, _currentListingPrice, 1);

          case 27:
            _yield$AuctionHousePr3 = _context.sent;
            _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 1);
            sellerTradeState = _yield$AuctionHousePr4[0];
            _context.next = 32;
            return AuctionHouseProgram.findListingReceiptAddress(sellerTradeState);

          case 32:
            _yield$AuctionHousePr5 = _context.sent;
            _yield$AuctionHousePr6 = _slicedToArray(_yield$AuctionHousePr5, 1);
            listingReceipt = _yield$AuctionHousePr6[0];
            authority = auctionHouseAuthority;
            auctionHouseFeeAccount = new PublicKey(auctionHouseObj.auctionHouseFeeAccount);
            receipt = listingReceipt; // Cancel listing transactions

            cancelInstructionAccounts = {
              wallet: sellerPublicKey,
              tokenAccount: associatedTokenAccount,
              tokenMint: _mint,
              authority: authority,
              auctionHouse: auctionHouse,
              auctionHouseFeeAccount: auctionHouseFeeAccount,
              tradeState: sellerTradeState
            };
            cancelInstructionArgs = {
              buyerPrice: _currentListingPrice,
              tokenSize: 1
            };
            cancelListingReceiptAccounts = {
              receipt: receipt,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            }; // Create new listing transactions

            listingPrice = _newListingPrice;
            _context.next = 44;
            return getMetadata(_mint);

          case 44:
            nftMetadataAccount = _context.sent;
            _context.next = 47;
            return AuctionHouseProgram.findTradeStateAddress(sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, listingPrice, 1);

          case 47:
            _yield$AuctionHousePr7 = _context.sent;
            _yield$AuctionHousePr8 = _slicedToArray(_yield$AuctionHousePr7, 2);
            newSellerTradeState = _yield$AuctionHousePr8[0];
            newTradeStateBump = _yield$AuctionHousePr8[1];
            // There is an edge case in which the user
            // tries to update the listing to a value of the same
            // previous price. If this occurs, we prevent the user
            // from updating a listing to the same price as the previous one
            console.log('newSellerTradeState.toBase58() === sellerTradeState.toBase58()', newSellerTradeState.toBase58() === sellerTradeState.toBase58());

            if (!(newSellerTradeState.toBase58() === sellerTradeState.toBase58())) {
              _context.next = 54;
              break;
            }

            throw new ListingAlreadyExistsError();

          case 54:
            _context.next = 56;
            return AuctionHouseProgram.findTradeStateAddress(sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, 0, 1);

          case 56:
            _yield$AuctionHousePr9 = _context.sent;
            _yield$AuctionHousePr10 = _slicedToArray(_yield$AuctionHousePr9, 2);
            newFreeTradeState = _yield$AuctionHousePr10[0];
            newFreeTradeBump = _yield$AuctionHousePr10[1];
            _context.next = 62;
            return AuctionHouseProgram.findListingReceiptAddress(newSellerTradeState);

          case 62:
            _yield$AuctionHousePr11 = _context.sent;
            _yield$AuctionHousePr12 = _slicedToArray(_yield$AuctionHousePr11, 2);
            newListingReceipt = _yield$AuctionHousePr12[0];
            newListingReceiptBump = _yield$AuctionHousePr12[1];
            console.log('[newSellerTradeState, newListingReceipt]', [newSellerTradeState.toBase58(), newListingReceipt.toBase58()]); // Create sell instruction accounts

            sellInstructionAccounts = {
              auctionHouse: auctionHouse,
              auctionHouseFeeAccount: new PublicKey(auctionHouseObj.auctionHouseFeeAccount),
              authority: new PublicKey(auctionHouseObj.authority),
              wallet: sellerPublicKey,
              metadata: nftMetadataAccount,
              tokenAccount: associatedTokenAccount,
              freeSellerTradeState: newFreeTradeState,
              sellerTradeState: newSellerTradeState,
              programAsSigner: programAsSigner
            };
            sellInstructionArgs = {
              buyerPrice: listingPrice,
              freeTradeStateBump: newFreeTradeBump,
              tradeStateBump: newTradeStateBump,
              programAsSignerBump: programAsSignerBump,
              tokenSize: 1
            }; // Create listing receipt accounts

            printListingReceiptInstructionAccounts = {
              receipt: newListingReceipt,
              bookkeeper: sellerPublicKey,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            };
            printListingReceiptInstructionArgs = {
              receiptBump: newListingReceiptBump
            };
            _context.next = 73;
            return createCancelInstruction(cancelInstructionAccounts, cancelInstructionArgs);

          case 73:
            cancelInstruction = _context.sent;
            cancelListingReceiptInstruction = createCancelListingReceiptInstruction(cancelListingReceiptAccounts);
            _context.next = 77;
            return createSellInstruction$1(sellInstructionAccounts, sellInstructionArgs);

          case 77:
            sellInstruction = _context.sent;
            printListingReceiptInstruction = createPrintListingReceiptInstruction$1(printListingReceiptInstructionAccounts, printListingReceiptInstructionArgs);
            transaction = new Transaction();
            transaction.add(cancelInstruction).add(cancelListingReceiptInstruction).add(sellInstruction).add(printListingReceiptInstruction);
            return _context.abrupt("return", [transaction, receipt]);

          case 82:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createUpdateListingTransaction.apply(this, arguments);
}

function createTransferInstruction(_x, _x2, _x3, _x4, _x5, _x6, _x7) {
  return _createTransferInstruction.apply(this, arguments);
}

function _createTransferInstruction() {
  _createTransferInstruction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(mint, recipient, holderPublicKey, auctionHouse, auctionHouseAuthority, program, connection) {
    var _mint, _recipient, txt, _yield$getNftOwner, _yield$getNftOwner2, senderAddress, sender, auctionHouseObj, senderAta, recipientAta, createAtaInstruction, tokenTransactions, isTokenOnSale, cancelListingTransactionsPromises, cancelListingTransactions, transferNftInstruction;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _mint = new PublicKey(mint);
            _recipient = new PublicKey(recipient);
            txt = new Transaction();
            _context2.next = 5;
            return getNftOwner(mint, connection);

          case 5:
            _yield$getNftOwner = _context2.sent;
            _yield$getNftOwner2 = _slicedToArray(_yield$getNftOwner, 3);
            senderAddress = _yield$getNftOwner2[0];
            sender = _yield$getNftOwner2[1];

            if (!(holderPublicKey.toBase58() !== senderAddress)) {
              _context2.next = 12;
              break;
            }

            throw new Error('You cannot list an NFT you do not own');

          case 12:
            _context2.next = 14;
            return program.account.auctionHouse.fetch(auctionHouse);

          case 14:
            auctionHouseObj = _context2.sent;
            _context2.next = 17;
            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, _mint, sender);

          case 17:
            senderAta = _context2.sent;
            _context2.next = 20;
            return Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, _mint, _recipient);

          case 20:
            recipientAta = _context2.sent;
            console.log('recipient  Associated Token Account', recipientAta);
            _context2.prev = 22;
            _context2.next = 25;
            return getAccountInfo(connection, recipientAta);

          case 25:
            _context2.next = 35;
            break;

          case 27:
            _context2.prev = 27;
            _context2.t0 = _context2["catch"](22);

            if (!(_context2.t0.message === 'TokenAccountNotFoundError')) {
              _context2.next = 35;
              break;
            }

            console.log('Token Account not previously initialized. Creating Associated Token Account Instruction');
            _context2.next = 33;
            return Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, _mint, recipientAta, _recipient, holderPublicKey);

          case 33:
            createAtaInstruction = _context2.sent;
            txt.add(createAtaInstruction);

          case 35:
            _context2.next = 37;
            return getTokenTransactions(_mint, auctionHouse, connection);

          case 37:
            tokenTransactions = _context2.sent;
            isTokenOnSale = tokenTransactions.filter(function (receipt) {
              return (receipt === null || receipt === void 0 ? void 0 : receipt.receipt_type) === 'listing_receipt' && !receipt.purchaseReceipt;
            });

            if (!isTokenOnSale.length) {
              _context2.next = 46;
              break;
            }

            console.info('Found pre-existing listings for >>> ', mint.toString(), 'Cancelling these listings before transfer'); // For each token we shall create a cancelListing transaction and then parse them and append to the chain

            cancelListingTransactionsPromises = isTokenOnSale.map( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_receipt) {
                var _buyerPrice, _yield$AuctionHousePr, _yield$AuctionHousePr2, sellerTradeState, _yield$AuctionHousePr3, _yield$AuctionHousePr4, listingReceipt, authority, auctionHouseFeeAccount, receipt, cancelInstructionAccounts, cancelInstructionArgs, cancelListingReceiptAccounts, cancelInstruction, cancelListingReceiptInstruction;

                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _buyerPrice = _receipt.price * LAMPORTS_PER_SOL;
                        _context.next = 3;
                        return AuctionHouseProgram.findTradeStateAddress(holderPublicKey, auctionHouse, senderAta, auctionHouseObj.treasuryMint, _mint, _buyerPrice, 1);

                      case 3:
                        _yield$AuctionHousePr = _context.sent;
                        _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 1);
                        sellerTradeState = _yield$AuctionHousePr2[0];
                        _context.next = 8;
                        return AuctionHouseProgram.findListingReceiptAddress(sellerTradeState);

                      case 8:
                        _yield$AuctionHousePr3 = _context.sent;
                        _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 1);
                        listingReceipt = _yield$AuctionHousePr4[0];
                        authority = auctionHouseAuthority;
                        auctionHouseFeeAccount = new PublicKey(auctionHouseObj.auctionHouseFeeAccount);
                        receipt = listingReceipt;
                        cancelInstructionAccounts = {
                          wallet: holderPublicKey,
                          tokenAccount: senderAta,
                          tokenMint: _mint,
                          authority: authority,
                          auctionHouse: auctionHouse,
                          auctionHouseFeeAccount: auctionHouseFeeAccount,
                          tradeState: sellerTradeState
                        };
                        cancelInstructionArgs = {
                          buyerPrice: _buyerPrice,
                          tokenSize: 1
                        };
                        cancelListingReceiptAccounts = {
                          receipt: receipt,
                          instruction: SYSVAR_INSTRUCTIONS_PUBKEY
                        };
                        _context.next = 19;
                        return createCancelInstruction(cancelInstructionAccounts, cancelInstructionArgs);

                      case 19:
                        cancelInstruction = _context.sent;
                        cancelListingReceiptInstruction = createCancelListingReceiptInstruction(cancelListingReceiptAccounts);
                        return _context.abrupt("return", [cancelInstruction, cancelListingReceiptInstruction]);

                      case 22:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x8) {
                return _ref.apply(this, arguments);
              };
            }());
            _context2.next = 44;
            return Promise.all(cancelListingTransactionsPromises);

          case 44:
            cancelListingTransactions = _context2.sent.flat();
            cancelListingTransactions.forEach(function (instruction) {
              return txt.add(instruction);
            });

          case 46:
            _context2.next = 48;
            return Token.createTransferInstruction(TOKEN_PROGRAM_ID, senderAta, recipientAta, sender, [], 1);

          case 48:
            transferNftInstruction = _context2.sent;
            txt.add(transferNftInstruction);
            return _context2.abrupt("return", txt);

          case 51:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[22, 27]]);
  }));
  return _createTransferInstruction.apply(this, arguments);
}

var MetadataKey$1;

(function (MetadataKey) {
  MetadataKey[MetadataKey["Uninitialized"] = 0] = "Uninitialized";
  MetadataKey[MetadataKey["MetadataV1"] = 4] = "MetadataV1";
  MetadataKey[MetadataKey["EditionV1"] = 1] = "EditionV1";
  MetadataKey[MetadataKey["MasterEditionV1"] = 2] = "MasterEditionV1";
  MetadataKey[MetadataKey["MasterEditionV2"] = 6] = "MasterEditionV2";
  MetadataKey[MetadataKey["EditionMarker"] = 7] = "EditionMarker";
})(MetadataKey$1 || (MetadataKey$1 = {}));

var Creator$1 = function Creator(args) {
  _classCallCheck(this, Creator);

  this.address = args.address;
  this.verified = args.verified;
  this.share = args.share;
};
var Data = function Data(args) {
  _classCallCheck(this, Data);

  this.name = args.name;
  this.symbol = args.symbol;
  this.uri = args.uri;
  this.sellerFeeBasisPoints = args.sellerFeeBasisPoints;
  this.creators = args.creators;
};
var CreateMetadataArgs = function CreateMetadataArgs(args) {
  _classCallCheck(this, CreateMetadataArgs);

  _defineProperty(this, "instruction", 0);

  this.data = args.data;
  this.isMutable = args.isMutable;
};
var UpdateMetadataArgs = function UpdateMetadataArgs(args) {
  _classCallCheck(this, UpdateMetadataArgs);

  _defineProperty(this, "instruction", 1);

  this.data = args.data ? args.data : null;
  this.updateAuthority = args.updateAuthority ? args.updateAuthority : null;
  this.primarySaleHappened = args.primarySaleHappened;
};
var CreateMasterEditionArgs = function CreateMasterEditionArgs(args) {
  _classCallCheck(this, CreateMasterEditionArgs);

  _defineProperty(this, "instruction", 10);

  this.maxSupply = args.maxSupply;
};
var Metadata = // set lazy
function Metadata(args) {
  var _args$editionNonce;

  _classCallCheck(this, Metadata);

  this.key = MetadataKey$1.MetadataV1;
  this.updateAuthority = args.updateAuthority;
  this.mint = args.mint;
  this.data = args.data;
  this.primarySaleHappened = args.primarySaleHappened;
  this.isMutable = args.isMutable;
  this.editionNonce = (_args$editionNonce = args.editionNonce) !== null && _args$editionNonce !== void 0 ? _args$editionNonce : null;
};
var METADATA_SCHEMA = new Map([[CreateMetadataArgs, {
  kind: 'struct',
  fields: [['instruction', 'u8'], ['data', Data], ['isMutable', 'u8'] // bool
  ]
}], [CreateMasterEditionArgs, {
  kind: 'struct',
  fields: [['instruction', 'u8'], ['maxSupply', {
    kind: 'option',
    type: 'u64'
  }]]
}], [UpdateMetadataArgs, {
  kind: 'struct',
  fields: [['instruction', 'u8'], ['data', {
    kind: 'option',
    type: Data
  }], ['updateAuthority', {
    kind: 'option',
    type: 'pubkeyAsString'
  }], ['primarySaleHappened', {
    kind: 'option',
    type: 'u8'
  }]]
}], [Data, {
  kind: 'struct',
  fields: [['name', 'string'], ['symbol', 'string'], ['uri', 'string'], ['sellerFeeBasisPoints', 'u16'], ['creators', {
    kind: 'option',
    type: [Creator$1]
  }]]
}], [Creator$1, {
  kind: 'struct',
  fields: [['address', 'pubkeyAsString'], ['verified', 'u8'], ['share', 'u8']]
}], [Metadata, {
  kind: 'struct',
  fields: [['key', 'u8'], ['updateAuthority', 'pubkeyAsString'], ['mint', 'pubkeyAsString'], ['data', Data], ['primarySaleHappened', 'u8'], // bool
  ['isMutable', 'u8'], // bool
  ['editionNonce', {
    kind: 'option',
    type: 'u8'
  }]]
}]]); // eslint-disable-next-line no-control-regex

var METADATA_REPLACE = new RegExp("\0", 'g');
var decodeMetadata = function decodeMetadata(buffer) {
  var metadata = deserializeUnchecked(METADATA_SCHEMA, Metadata, buffer);
  metadata.data.name = metadata.data.name.replace(METADATA_REPLACE, '');
  metadata.data.uri = metadata.data.uri.replace(METADATA_REPLACE, '');
  metadata.data.symbol = metadata.data.symbol.replace(METADATA_REPLACE, '');
  return metadata;
};
var extendBorsh = function extendBorsh() {
  BinaryReader.prototype.readPubkey = function () {
    var reader = this;
    var array = reader.readFixedArray(32);
    return new PublicKey(array);
  };

  BinaryWriter.prototype.writePubkey = function (value) {
    var writer = this;
    writer.writeFixedArray(value.toBuffer());
  };

  BinaryReader.prototype.readPubkeyAsString = function () {
    var reader = this;
    var array = reader.readFixedArray(32);
    return base58.encode(array);
  };

  BinaryWriter.prototype.writePubkeyAsString = function (value) {
    var writer = this;
    writer.writeFixedArray(base58.decode(value));
  };
};
extendBorsh();

var _AuctionHouseProgram$ = AuctionHouseProgram.instructions,
    createPrintPurchaseReceiptInstruction = _AuctionHouseProgram$.createPrintPurchaseReceiptInstruction,
    createPublicBuyInstruction = _AuctionHouseProgram$.createPublicBuyInstruction,
    createExecuteSaleInstruction = _AuctionHouseProgram$.createExecuteSaleInstruction,
    createPrintBidReceiptInstruction = _AuctionHouseProgram$.createPrintBidReceiptInstruction;
/**
 * Create Buy Transaction object
 * @param mint
 * @param buyerPrice
 * @param buyer
 * @param auctionHouse
 * @param program
 * @param connection
 */

function createBuyTransaction(_x, _x2, _x3, _x4, _x5, _x6) {
  return _createBuyTransaction.apply(this, arguments);
}

function _createBuyTransaction() {
  _createBuyTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(mint, buyerPrice, buyer, auctionHouse, program, connection) {
    var _buyerPrice, _mint, _yield$getNftOwner, _yield$getNftOwner2, sellerAddressAsString, _sellerPublicKey, tokenSize, buyerWallet, auctionHouseObj, _yield$AuctionHousePr, _yield$AuctionHousePr2, escrowPaymentAccount, escrowPaymentBump, results, metadata, tokenAccount, _yield$AuctionHousePr3, _yield$AuctionHousePr4, buyerTradeState, tradeStateBump, publicBuyInstructionAccounts, publicBuyInstructionArgs, publicBuyInstruction, _yield$getAtaForMint, _yield$getAtaForMint2, associatedTokenAccount, _yield$AuctionHousePr5, _yield$AuctionHousePr6, sellerTradeState, _yield$AuctionHousePr7, _yield$AuctionHousePr8, freeTradeState, freeTradeStateBump, _yield$AuctionHousePr9, _yield$AuctionHousePr10, programAsSigner, programAsSignerBump, _yield$AuctionHousePr11, _yield$AuctionHousePr12, buyerReceiptTokenAccount, metadataObj, metadataDecoded, creatorAccounts, executeSaleInstructionAccounts, createExecuteSaleInstructionArgs, _executeSaleInstruction, _yield$AuctionHousePr13, _yield$AuctionHousePr14, bidReceipt, bidReceiptBump, _yield$AuctionHousePr15, _yield$AuctionHousePr16, purchaseReceipt, purchaseReceiptBump, _yield$AuctionHousePr17, _yield$AuctionHousePr18, listingReceipt, printBidReceiptInstructionAccounts, printBidReceiptInstructionArgs, printPurchaseReceiptInstructionAccounts, printPurchaseReceiptInstructionArgs, printBidReceiptInstruction, printPurchaseReceiptInstruction, executeSaleInstruction, transaction;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _buyerPrice = Number(buyerPrice) * LAMPORTS_PER_SOL;
            _mint = new PublicKey(mint);
            _context.next = 4;
            return getNftOwner(mint, connection);

          case 4:
            _yield$getNftOwner = _context.sent;
            _yield$getNftOwner2 = _slicedToArray(_yield$getNftOwner, 2);
            sellerAddressAsString = _yield$getNftOwner2[0];
            _sellerPublicKey = _yield$getNftOwner2[1];

            if (!(buyer.toBase58() === sellerAddressAsString)) {
              _context.next = 10;
              break;
            }

            throw new Error('You cannot buy your own NFT');

          case 10:
            /** Limit token size to 1 */
            tokenSize = 1; // User wallet.

            buyerWallet = buyer;
            console.log({
              _mint: _mint.toBase58(),
              _sellerPublicKey: buyer.toBase58(),
              buyingPrice: buyerPrice
            });
            _context.next = 15;
            return program.account.auctionHouse.fetch(auctionHouse);

          case 15:
            auctionHouseObj = _context.sent;
            _context.next = 18;
            return AuctionHouseProgram.findEscrowPaymentAccountAddress(auctionHouse, buyerWallet);

          case 18:
            _yield$AuctionHousePr = _context.sent;
            _yield$AuctionHousePr2 = _slicedToArray(_yield$AuctionHousePr, 2);
            escrowPaymentAccount = _yield$AuctionHousePr2[0];
            escrowPaymentBump = _yield$AuctionHousePr2[1];
            _context.next = 24;
            return program.provider.connection.getTokenLargestAccounts(_mint);

          case 24:
            results = _context.sent;
            _context.next = 27;
            return getMetadata(_mint);

          case 27:
            metadata = _context.sent;

            /**
             * Token account of the token to purchase,
             * This will default to finding the one with
             * highest balance (of NFTs)
             * */
            tokenAccount = results.value[0].address;
            _context.next = 31;
            return AuctionHouseProgram.findPublicBidTradeStateAddress(buyerWallet, auctionHouse, auctionHouseObj.treasuryMint, _mint, _buyerPrice, tokenSize);

          case 31:
            _yield$AuctionHousePr3 = _context.sent;
            _yield$AuctionHousePr4 = _slicedToArray(_yield$AuctionHousePr3, 2);
            buyerTradeState = _yield$AuctionHousePr4[0];
            tradeStateBump = _yield$AuctionHousePr4[1];
            publicBuyInstructionAccounts = {
              wallet: buyerWallet,
              transferAuthority: buyerWallet,
              paymentAccount: buyerWallet,
              treasuryMint: auctionHouseObj.treasuryMint,
              tokenAccount: tokenAccount,
              metadata: metadata,
              escrowPaymentAccount: escrowPaymentAccount,
              authority: new PublicKey(auctionHouseObj.authority),
              auctionHouse: auctionHouse,
              auctionHouseFeeAccount: new PublicKey(auctionHouseObj.auctionHouseFeeAccount),
              buyerTradeState: buyerTradeState
            };
            publicBuyInstructionArgs = {
              buyerPrice: _buyerPrice,
              escrowPaymentBump: escrowPaymentBump,
              tokenSize: tokenSize,
              tradeStateBump: tradeStateBump
            };
            publicBuyInstruction = createPublicBuyInstruction(publicBuyInstructionAccounts, publicBuyInstructionArgs);
            _context.next = 40;
            return getAtaForMint(_mint, _sellerPublicKey);

          case 40:
            _yield$getAtaForMint = _context.sent;
            _yield$getAtaForMint2 = _slicedToArray(_yield$getAtaForMint, 1);
            associatedTokenAccount = _yield$getAtaForMint2[0];
            _context.next = 45;
            return AuctionHouseProgram.findTradeStateAddress(_sellerPublicKey, auctionHouse, associatedTokenAccount, auctionHouseObj.treasuryMint, _mint, _buyerPrice, 1);

          case 45:
            _yield$AuctionHousePr5 = _context.sent;
            _yield$AuctionHousePr6 = _slicedToArray(_yield$AuctionHousePr5, 1);
            sellerTradeState = _yield$AuctionHousePr6[0];
            _context.next = 50;
            return AuctionHouseProgram.findTradeStateAddress(_sellerPublicKey, auctionHouse, tokenAccount, auctionHouseObj.treasuryMint, _mint, 0, 1);

          case 50:
            _yield$AuctionHousePr7 = _context.sent;
            _yield$AuctionHousePr8 = _slicedToArray(_yield$AuctionHousePr7, 2);
            freeTradeState = _yield$AuctionHousePr8[0];
            freeTradeStateBump = _yield$AuctionHousePr8[1];
            _context.next = 56;
            return AuctionHouseProgram.findAuctionHouseProgramAsSignerAddress();

          case 56:
            _yield$AuctionHousePr9 = _context.sent;
            _yield$AuctionHousePr10 = _slicedToArray(_yield$AuctionHousePr9, 2);
            programAsSigner = _yield$AuctionHousePr10[0];
            programAsSignerBump = _yield$AuctionHousePr10[1];
            _context.next = 62;
            return AuctionHouseProgram.findAssociatedTokenAccountAddress(_mint, buyerWallet);

          case 62:
            _yield$AuctionHousePr11 = _context.sent;
            _yield$AuctionHousePr12 = _slicedToArray(_yield$AuctionHousePr11, 1);
            buyerReceiptTokenAccount = _yield$AuctionHousePr12[0];
            _context.next = 67;
            return program.provider.connection.getAccountInfo(metadata);

          case 67:
            metadataObj = _context.sent;
            metadataDecoded = decodeMetadata(Buffer.from(metadataObj.data));
            creatorAccounts = metadataDecoded.data.creators.map(function (c) {
              return {
                pubkey: new PublicKey(c.address),
                isWritable: true,
                isSigner: false
              };
            });
            executeSaleInstructionAccounts = {
              buyer: buyerWallet,
              seller: _sellerPublicKey,
              tokenAccount: tokenAccount,
              tokenMint: _mint,
              metadata: metadata,
              auctionHouse: auctionHouse,
              treasuryMint: auctionHouseObj.treasuryMint,
              authority: new PublicKey(auctionHouseObj.authority),
              auctionHouseFeeAccount: new PublicKey(auctionHouseObj.auctionHouseFeeAccount),
              auctionHouseTreasury: new PublicKey(auctionHouseObj.auctionHouseTreasury),
              escrowPaymentAccount: escrowPaymentAccount,
              programAsSigner: programAsSigner,
              sellerPaymentReceiptAccount: _sellerPublicKey,
              buyerReceiptTokenAccount: buyerReceiptTokenAccount,
              buyerTradeState: buyerTradeState,
              sellerTradeState: sellerTradeState,
              freeTradeState: freeTradeState
            };
            createExecuteSaleInstructionArgs = {
              escrowPaymentBump: escrowPaymentBump,
              freeTradeStateBump: freeTradeStateBump,
              programAsSignerBump: programAsSignerBump,
              buyerPrice: buyerPrice,
              tokenSize: tokenSize,
              // @ts-ignore
              partialOrderSize: null,
              partialOrderPrice: null
            };
            _context.next = 74;
            return createExecuteSaleInstruction(executeSaleInstructionAccounts, createExecuteSaleInstructionArgs);

          case 74:
            _executeSaleInstruction = _context.sent;
            _context.next = 77;
            return AuctionHouseProgram.findBidReceiptAddress(buyerTradeState);

          case 77:
            _yield$AuctionHousePr13 = _context.sent;
            _yield$AuctionHousePr14 = _slicedToArray(_yield$AuctionHousePr13, 2);
            bidReceipt = _yield$AuctionHousePr14[0];
            bidReceiptBump = _yield$AuctionHousePr14[1];
            // Executing sale:
            console.log('===== EXECUTING SALE =====');
            console.log('[buyerTradeState, bidReceipt]', [buyerTradeState.toBase58(), bidReceipt.toBase58()]);
            _context.next = 85;
            return AuctionHouseProgram.findPurchaseReceiptAddress(sellerTradeState, buyerTradeState);

          case 85:
            _yield$AuctionHousePr15 = _context.sent;
            _yield$AuctionHousePr16 = _slicedToArray(_yield$AuctionHousePr15, 2);
            purchaseReceipt = _yield$AuctionHousePr16[0];
            purchaseReceiptBump = _yield$AuctionHousePr16[1];
            _context.next = 91;
            return AuctionHouseProgram.findListingReceiptAddress(sellerTradeState);

          case 91:
            _yield$AuctionHousePr17 = _context.sent;
            _yield$AuctionHousePr18 = _slicedToArray(_yield$AuctionHousePr17, 1);
            listingReceipt = _yield$AuctionHousePr18[0];
            console.log('[sellerTradeState, listingReceipt]', [sellerTradeState.toBase58(), listingReceipt.toBase58()]);
            printBidReceiptInstructionAccounts = {
              bookkeeper: buyerWallet,
              receipt: bidReceipt,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            };
            printBidReceiptInstructionArgs = {
              receiptBump: bidReceiptBump
            };
            printPurchaseReceiptInstructionAccounts = {
              bookkeeper: buyerWallet,
              purchaseReceipt: purchaseReceipt,
              bidReceipt: bidReceipt,
              listingReceipt: listingReceipt,
              instruction: SYSVAR_INSTRUCTIONS_PUBKEY
            };
            printPurchaseReceiptInstructionArgs = {
              purchaseReceiptBump: purchaseReceiptBump
            };
            printBidReceiptInstruction = createPrintBidReceiptInstruction(printBidReceiptInstructionAccounts, printBidReceiptInstructionArgs);
            printPurchaseReceiptInstruction = createPrintPurchaseReceiptInstruction(printPurchaseReceiptInstructionAccounts, printPurchaseReceiptInstructionArgs);
            executeSaleInstruction = new TransactionInstruction({
              programId: AuctionHouseProgram.PUBKEY,
              data: _executeSaleInstruction.data,
              // @ts-ignore
              keys: [].concat(_toConsumableArray(_executeSaleInstruction.keys), _toConsumableArray(creatorAccounts))
            });
            transaction = new Transaction();
            transaction.add(publicBuyInstruction).add(printBidReceiptInstruction).add(executeSaleInstruction).add(printPurchaseReceiptInstruction);
            return _context.abrupt("return", [transaction, purchaseReceipt]);

          case 105:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _createBuyTransaction.apply(this, arguments);
}

var index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createCancelListingTransaction: createCancelListingTransaction,
  createListingTransaction: createListingTransaction,
  createUpdateListingTransaction: createUpdateListingTransaction,
  createTransferInstruction: createTransferInstruction,
  createBuyTransaction: createBuyTransaction
});

var __ErrorCodes__ = {
  WALLET_NOT_INITIALIZED: {
    error: 'WALLET_NOT_INITIALIZED',
    code: 300101,
    message: "Wallet has not been initialized in SDK"
  },
  AUCTION_HOUSE_NOT_INITIALIZED: {
    error: 'AUCTION_HOUSE_NOT_INITIALIZED',
    code: 300102,
    message: "AuctionHouse not been initialized in SDK"
  },
  PROGRAM_NOT_INITIALIZED: {
    error: 'PROGRAM_NOT_INITIALIZED',
    code: 300103,
    message: "Program not been initialized in SDK"
  }
};
var ErrorCodes = __ErrorCodes__;
var MirageClientError = /*#__PURE__*/function (_Error) {
  _inherits(MirageClientError, _Error);

  var _super = _createSuper(MirageClientError);

  function MirageClientError(error) {
    var _this;

    _classCallCheck(this, MirageClientError);

    var message;

    if (typeof error.message === 'function') {
      message = error.message();
    } else {
      message = error.message;
    }

    _this = _super.call(this, message);

    _defineProperty(_assertThisInitialized(_this), "data", null);

    _this.message = message;
    _this.code = error.code;
    _this.error = error.error;
    _this.data = null;
    return _this;
  }

  _createClass(MirageClientError, null, [{
    key: "new",
    value: function _new(errorCode, message) {
      var error = ErrorCodes[errorCode];
      var payload = new MirageClientError(error);
      if (message) return MirageClientError.withMessage(payload, message);else return payload;
    }
  }, {
    key: "withMessage",
    value: function withMessage(error, _message) {
      var message;

      if (typeof _message === 'function') {
        message = _message();
      } else {
        message = _message;
      }

      error.message = message;
      return error;
    }
  }]);

  return MirageClientError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/* Throws parsed error based on MirrorWorld API Error Standard */

function throwError(error, customMessage) {
  throw MirageClientError["new"](error, customMessage);
}

var Mirage = /*#__PURE__*/function () {
  function Mirage(_ref) {
    var auctionHouseAuthority = _ref.auctionHouseAuthority,
        connection = _ref.connection,
        wallet = _ref.wallet,
        NFTStorageAPIKey = _ref.NFTStorageAPIKey,
        _ref$mintConfig = _ref.mintConfig,
        userMintConfig = _ref$mintConfig === void 0 ? MINT_CONFIG : _ref$mintConfig;

    _classCallCheck(this, Mirage);

    this.auctionHouseAuthority = auctionHouseAuthority;
    this.connection = connection;
    this.wallet = wallet;
    this.mintConfig = merge(MINT_CONFIG, userMintConfig);
    this.NFTStorageAPIKey = NFTStorageAPIKey;
    this.metaplex = new Metaplex(connection);
    this.setup();
  }

  _createClass(Mirage, [{
    key: "setup",
    value: function () {
      var _setup = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        var _yield$this$getAuctio, _yield$this$getAuctio2, auctionHouse;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getProvider('processed');

              case 2:
                this._provider = _context.sent;
                console.log({
                  wallet: this.wallet.publicKey.toBase58(),
                  auctionHouseSigner: this.auctionHouseAuthority.toBase58()
                });
                /**
                 * 1. Create auctionHouse
                 * 2. List token by seller
                 * 3. Buy token by buyer
                 * 4. Cancel listing
                 */

                _context.next = 6;
                return this.getAuctionHouseAddress();

              case 6:
                _yield$this$getAuctio = _context.sent;
                _yield$this$getAuctio2 = _slicedToArray(_yield$this$getAuctio, 1);
                auctionHouse = _yield$this$getAuctio2[0];
                this.auctionHouse = auctionHouse;
                _context.next = 12;
                return this.loadAuctionHouseProgram();

              case 12:
                this.program = _context.sent;
                console.log('Auctionhouse initialized at address', auctionHouse.toBase58());
                console.log('Mirage SDK ready', {
                  wallet: this.wallet.publicKey.toBase58(),
                  auctionHouse: auctionHouse.toBase58(),
                  auctionHouseSigner: this.auctionHouseAuthority.toBase58()
                });

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function setup() {
        return _setup.apply(this, arguments);
      }

      return setup;
    }()
    /** Get user's NFTs */

  }, {
    key: "getUserNfts",
    value: function () {
      var _getUserNfts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(publicKey) {
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.metaplex.nfts().findAllByOwner(publicKey));

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUserNfts(_x) {
        return _getUserNfts.apply(this, arguments);
      }

      return getUserNfts;
    }()
    /** Get single NFT by mint */

  }, {
    key: "getNft",
    value: function () {
      var _getNft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(mintKey) {
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.metaplex.nfts().findByMint(mintKey));

              case 1:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getNft(_x2) {
        return _getNft.apply(this, arguments);
      }

      return getNft;
    }()
    /** Gets the owner of an NFT */

  }, {
    key: "getNftOwner",
    value: function () {
      var _getNftOwner2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(mint) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", getNftOwner(mint, this.connection));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getNftOwner$1(_x3) {
        return _getNftOwner2.apply(this, arguments);
      }

      return getNftOwner$1;
    }()
    /** Determines whether the client is the owner of the auctionhouse */

  }, {
    key: "clientIsOwner",
    get: function get() {
      return this.auctionHouseAuthority.toBase58() === this.wallet.publicKey.toBase58();
    }
    /** Get the auction house addresses by the owner */

  }, {
    key: "getAuctionHouseAddress",
    value: function () {
      var _getAuctionHouseAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (this.auctionHouseAuthority) {
                  _context5.next = 2;
                  break;
                }

                throw new Error('auctionHouseAuthority not provided');

              case 2:
                return _context5.abrupt("return", AuctionHouseProgram.findAuctionHouseAddress(this.auctionHouseAuthority, new PublicKey('So11111111111111111111111111111111111111112')));

              case 3:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getAuctionHouseAddress() {
        return _getAuctionHouseAddress.apply(this, arguments);
      }

      return getAuctionHouseAddress;
    }()
    /** Loads provider instance */

  }, {
    key: "getProvider",
    value: function () {
      var _getProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6() {
        var commitment,
            wallet,
            _args6 = arguments;
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                commitment = _args6.length > 0 && _args6[0] !== undefined ? _args6[0] : 'processed';
                wallet = this.wallet;
                return _context6.abrupt("return", new Provider(this.connection, wallet, {
                  preflightCommitment: commitment
                }));

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function getProvider() {
        return _getProvider.apply(this, arguments);
      }

      return getProvider;
    }()
    /** Loads auctionhouse program */

  }, {
    key: "loadAuctionHouseProgram",
    value: function () {
      var _loadAuctionHouseProgram = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
        var provider;
        return regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                provider = new Provider(this.connection, this.wallet, {
                  preflightCommitment: 'recent'
                });
                return _context7.abrupt("return", new Program(AuctionHouseIDL, AUCTION_HOUSE_PROGRAM_ID, provider));

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function loadAuctionHouseProgram() {
        return _loadAuctionHouseProgram.apply(this, arguments);
      }

      return loadAuctionHouseProgram;
    }()
    /**
     * Create listing transaction
     * @param mint
     * @param listingPrice
     * @param sellerPublicKey
     */

  }, {
    key: "createListTransaction",
    value: function () {
      var _createListTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(mint, listingPrice, sellerPublicKey) {
        var _yield$this$getAuctio3, _yield$this$getAuctio4;

        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!this.wallet) {
                  throwError('WALLET_NOT_INITIALIZED');
                }

                if (!this.auctionHouse) {
                  throwError('AUCTION_HOUSE_NOT_INITIALIZED');
                }

                if (this.auctionHouse) {
                  _context8.next = 8;
                  break;
                }

                _context8.next = 5;
                return this.getAuctionHouseAddress();

              case 5:
                _yield$this$getAuctio3 = _context8.sent;
                _yield$this$getAuctio4 = _slicedToArray(_yield$this$getAuctio3, 1);
                this.auctionHouse = _yield$this$getAuctio4[0];

              case 8:
                if (this.program) {
                  _context8.next = 12;
                  break;
                }

                _context8.next = 11;
                return this.loadAuctionHouseProgram();

              case 11:
                this.program = _context8.sent;

              case 12:
                if (!this.program) {
                  throwError('PROGRAM_NOT_INITIALIZED');
                }

                return _context8.abrupt("return", createListingTransaction(mint, listingPrice, sellerPublicKey, this.auctionHouse, this.program));

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function createListTransaction(_x4, _x5, _x6) {
        return _createListTransaction.apply(this, arguments);
      }

      return createListTransaction;
    }()
    /**
     * Lists an NFT for sale.
     * @param mint NFT mint address to be sold
     * @param _listingPrice price at which NFT will be sold
     */

  }, {
    key: "listToken",
    value: function () {
      var _listToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(mint, _listingPrice) {
        var sellerWallet, _yield$this$createLis, _yield$this$createLis2, txt, receipt, estimatedCost, _yield$this$connectio, _balance, balance, signed, signature, result;

        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                sellerWallet = this.wallet;
                _context9.next = 3;
                return this.createListTransaction(new PublicKey(mint), _listingPrice, sellerWallet.publicKey);

              case 3:
                _yield$this$createLis = _context9.sent;
                _yield$this$createLis2 = _slicedToArray(_yield$this$createLis, 2);
                txt = _yield$this$createLis2[0];
                receipt = _yield$this$createLis2[1];
                _context9.next = 9;
                return this.connection.getLatestBlockhash();

              case 9:
                txt.recentBlockhash = _context9.sent.blockhash;
                txt.feePayer = sellerWallet.publicKey;
                _context9.next = 13;
                return txt.getEstimatedFee(this.connection);

              case 13:
                _context9.t0 = _context9.sent;
                _context9.t1 = LAMPORTS_PER_SOL;
                estimatedCost = _context9.t0 / _context9.t1;
                _context9.next = 18;
                return this.connection.getBalanceAndContext(this.wallet.publicKey);

              case 18:
                _yield$this$connectio = _context9.sent;
                _balance = _yield$this$connectio.value;
                balance = _balance / LAMPORTS_PER_SOL;
                console.info('Estimated cost of transaction: ', estimatedCost);
                console.info('Wallet Balance', balance, '');

                if (!(balance < estimatedCost)) {
                  _context9.next = 25;
                  break;
                }

                throw new InsufficientBalanceError('Account balance is not enough to complete this sell transaction');

              case 25:
                signed = undefined;
                _context9.prev = 26;
                _context9.next = 29;
                return sellerWallet.signTransaction(txt);

              case 29:
                signed = _context9.sent;
                _context9.next = 36;
                break;

              case 32:
                _context9.prev = 32;
                _context9.t2 = _context9["catch"](26);
                console.error('Seller cancelled transaction', _context9.t2);
                throw _context9.t2;

              case 36:
                signature = undefined;
                _context9.prev = 37;
                _context9.next = 40;
                return this.connection.sendRawTransaction(signed.serialize());

              case 40:
                signature = _context9.sent;
                _context9.next = 43;
                return this.connection.confirmTransaction(signature, 'confirmed');

              case 43:
                result = _context9.sent;
                _context9.next = 49;
                break;

              case 46:
                _context9.prev = 46;
                _context9.t3 = _context9["catch"](37);
                programErrorHandler(_context9.t3);

              case 49:
                console.debug('result:', result);
                console.debug('Successfully listed ', mint, ' at ', _listingPrice, ' SOL');
                return _context9.abrupt("return", [result, receipt, signature]);

              case 52:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[26, 32], [37, 46]]);
      }));

      function listToken(_x7, _x8) {
        return _listToken.apply(this, arguments);
      }

      return listToken;
    }()
    /**
     * Creates Buy transaction Object
     * @param mint
     * @param listingPrice
     * @param buyerPublicKey
     * @param connection
     */

  }, {
    key: "createBuyTransaction",
    value: function () {
      var _createBuyTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(mint, listingPrice, buyerPublicKey) {
        var connection,
            _yield$this$getAuctio5,
            _yield$this$getAuctio6,
            _args10 = arguments;

        return regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                connection = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : this.connection;

                if (!this.wallet) {
                  throwError('WALLET_NOT_INITIALIZED');
                }

                if (!this.auctionHouse) {
                  throwError('AUCTION_HOUSE_NOT_INITIALIZED');
                }

                if (this.auctionHouse) {
                  _context10.next = 9;
                  break;
                }

                _context10.next = 6;
                return this.getAuctionHouseAddress();

              case 6:
                _yield$this$getAuctio5 = _context10.sent;
                _yield$this$getAuctio6 = _slicedToArray(_yield$this$getAuctio5, 1);
                this.auctionHouse = _yield$this$getAuctio6[0];

              case 9:
                if (this.program) {
                  _context10.next = 13;
                  break;
                }

                _context10.next = 12;
                return this.loadAuctionHouseProgram();

              case 12:
                this.program = _context10.sent;

              case 13:
                if (!this.program) {
                  throwError('PROGRAM_NOT_INITIALIZED');
                }

                return _context10.abrupt("return", createBuyTransaction(mint, listingPrice, buyerPublicKey, this.auctionHouse, this.program, connection));

              case 15:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function createBuyTransaction$1(_x9, _x10, _x11) {
        return _createBuyTransaction2.apply(this, arguments);
      }

      return createBuyTransaction$1;
    }()
    /**
     * Creates Update Listing transaction Object
     * @param mint
     * @param currentListingPrice
     * @param newListingPrice
     * @param sellerPublicKey
     * @param auctionHouseAuthority
     * @param connection
     */

  }, {
    key: "createUpdateListingTransaction",
    value: function () {
      var _createUpdateListingTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(mint, currentListingPrice, newListingPrice, sellerPublicKey) {
        var auctionHouseAuthority,
            connection,
            _yield$this$getAuctio7,
            _yield$this$getAuctio8,
            _args11 = arguments;

        return regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                auctionHouseAuthority = _args11.length > 4 && _args11[4] !== undefined ? _args11[4] : this.auctionHouseAuthority;
                connection = _args11.length > 5 && _args11[5] !== undefined ? _args11[5] : this.connection;

                if (!this.wallet) {
                  throwError('WALLET_NOT_INITIALIZED');
                }

                if (!this.auctionHouse) {
                  throwError('AUCTION_HOUSE_NOT_INITIALIZED');
                }

                if (this.auctionHouse) {
                  _context11.next = 10;
                  break;
                }

                _context11.next = 7;
                return this.getAuctionHouseAddress();

              case 7:
                _yield$this$getAuctio7 = _context11.sent;
                _yield$this$getAuctio8 = _slicedToArray(_yield$this$getAuctio7, 1);
                this.auctionHouse = _yield$this$getAuctio8[0];

              case 10:
                if (this.program) {
                  _context11.next = 14;
                  break;
                }

                _context11.next = 13;
                return this.loadAuctionHouseProgram();

              case 13:
                this.program = _context11.sent;

              case 14:
                if (!this.program) {
                  throwError('PROGRAM_NOT_INITIALIZED');
                }

                return _context11.abrupt("return", createUpdateListingTransaction(mint, currentListingPrice, newListingPrice, sellerPublicKey, this.auctionHouse, this.program, auctionHouseAuthority, connection));

              case 16:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function createUpdateListingTransaction$1(_x12, _x13, _x14, _x15) {
        return _createUpdateListingTransaction2.apply(this, arguments);
      }

      return createUpdateListingTransaction$1;
    }()
    /**
     * Purchases an NFT that has been listed on sale
     * @param mint NFT mint address to be bought
     * @param _buyerPrice price at which NFT will be bought. This MUST match the selling price of the NFT
     */

  }, {
    key: "buyToken",
    value: function () {
      var _buyToken = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(mint, _buyerPrice) {
        var buyerWallet, _yield$this$createBuy, _yield$this$createBuy2, buyTxt, purchaseReceipt, estimatedCost, _yield$this$connectio2, _balance, balance, signed, signature, result;

        return regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                buyerWallet = this.wallet;
                _context12.next = 3;
                return this.createBuyTransaction(new PublicKey(mint), _buyerPrice, buyerWallet.publicKey);

              case 3:
                _yield$this$createBuy = _context12.sent;
                _yield$this$createBuy2 = _slicedToArray(_yield$this$createBuy, 2);
                buyTxt = _yield$this$createBuy2[0];
                purchaseReceipt = _yield$this$createBuy2[1];
                _context12.next = 9;
                return this.connection.getLatestBlockhash();

              case 9:
                buyTxt.recentBlockhash = _context12.sent.blockhash;
                buyTxt.feePayer = buyerWallet.publicKey;
                _context12.next = 13;
                return buyTxt.getEstimatedFee(this.connection);

              case 13:
                _context12.t0 = _context12.sent;
                _context12.t1 = LAMPORTS_PER_SOL;
                _context12.t2 = _context12.t0 / _context12.t1;
                _context12.t3 = Number(_buyerPrice);
                estimatedCost = _context12.t2 + _context12.t3;
                _context12.next = 20;
                return this.connection.getBalanceAndContext(this.wallet.publicKey);

              case 20:
                _yield$this$connectio2 = _context12.sent;
                _balance = _yield$this$connectio2.value;
                balance = _balance / LAMPORTS_PER_SOL;
                console.info('Estimated cost of transaction: ', estimatedCost);
                console.info('Wallet Balance', balance);

                if (!(balance < estimatedCost)) {
                  _context12.next = 27;
                  break;
                }

                throw new InsufficientBalanceError('Account balance is not enough to complete this purchase transaction');

              case 27:
                signed = undefined;
                _context12.prev = 28;
                _context12.next = 31;
                return buyerWallet.signTransaction(buyTxt);

              case 31:
                signed = _context12.sent;
                _context12.next = 38;
                break;

              case 34:
                _context12.prev = 34;
                _context12.t4 = _context12["catch"](28);
                console.error('Buyer cancelled transaction', _context12.t4.message);
                throw _context12.t4;

              case 38:
                signature = undefined;
                _context12.prev = 39;
                _context12.next = 42;
                return this.connection.sendRawTransaction(signed.serialize());

              case 42:
                signature = _context12.sent;
                _context12.next = 45;
                return this.connection.confirmTransaction(signature, 'confirmed');

              case 45:
                result = _context12.sent;
                _context12.next = 51;
                break;

              case 48:
                _context12.prev = 48;
                _context12.t5 = _context12["catch"](39);
                programErrorHandler(_context12.t5);

              case 51:
                console.debug('result', result);
                console.debug('Successfully purchased ', mint, ' at ', _buyerPrice, ' SOL');
                return _context12.abrupt("return", [result, purchaseReceipt, signature]);

              case 54:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this, [[28, 34], [39, 48]]);
      }));

      function buyToken(_x16, _x17) {
        return _buyToken.apply(this, arguments);
      }

      return buyToken;
    }()
    /**
     * Updates a current listing
     * @param mint
     * @param currentListingPrice
     * @param newListingPrice
     */

  }, {
    key: "updateListing",
    value: function () {
      var _updateListing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(mint, currentListingPrice, newListingPrice) {
        var sellerPublicKey, _yield$this$createUpd, _yield$this$createUpd2, txt, newListingReceipt, estimatedCost, _yield$this$connectio3, _balance, balance, signed, signature, result;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                sellerPublicKey = this.wallet.publicKey;
                _context13.next = 3;
                return this.createUpdateListingTransaction(new PublicKey(mint), currentListingPrice, newListingPrice, sellerPublicKey);

              case 3:
                _yield$this$createUpd = _context13.sent;
                _yield$this$createUpd2 = _slicedToArray(_yield$this$createUpd, 2);
                txt = _yield$this$createUpd2[0];
                newListingReceipt = _yield$this$createUpd2[1];
                _context13.next = 9;
                return this.connection.getLatestBlockhash();

              case 9:
                txt.recentBlockhash = _context13.sent.blockhash;
                txt.feePayer = this.wallet.publicKey;
                _context13.next = 13;
                return txt.getEstimatedFee(this.connection);

              case 13:
                _context13.t0 = _context13.sent;
                _context13.t1 = LAMPORTS_PER_SOL;
                estimatedCost = _context13.t0 / _context13.t1;
                _context13.next = 18;
                return this.connection.getBalanceAndContext(this.wallet.publicKey);

              case 18:
                _yield$this$connectio3 = _context13.sent;
                _balance = _yield$this$connectio3.value;
                balance = _balance / LAMPORTS_PER_SOL;
                console.info('Estimated cost of transaction: ', estimatedCost);
                console.info('Wallet Balance', balance, '');

                if (!(balance < estimatedCost)) {
                  _context13.next = 25;
                  break;
                }

                throw new InsufficientBalanceError('Account balance is not enough to complete this update listing transaction');

              case 25:
                signed = undefined;
                _context13.prev = 26;
                _context13.next = 29;
                return this.wallet.signTransaction(txt);

              case 29:
                signed = _context13.sent;
                _context13.next = 36;
                break;

              case 32:
                _context13.prev = 32;
                _context13.t2 = _context13["catch"](26);
                console.error('Seller cancelled transaction', _context13.t2);
                throw _context13.t2;

              case 36:
                signature = undefined;
                _context13.prev = 37;
                _context13.next = 40;
                return this.connection.sendRawTransaction(signed.serialize());

              case 40:
                signature = _context13.sent;
                _context13.next = 43;
                return this.connection.confirmTransaction(signature, 'confirmed');

              case 43:
                result = _context13.sent;
                _context13.next = 49;
                break;

              case 46:
                _context13.prev = 46;
                _context13.t3 = _context13["catch"](37);
                programErrorHandler(_context13.t3);

              case 49:
                console.log('result', result);
                console.log('Successfully changed listing price for ', mint, ' from ', currentListingPrice, ' SOL ', ' to ', newListingPrice); // Get new listing

                return _context13.abrupt("return", [result, newListingReceipt, signature]);

              case 52:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this, [[26, 32], [37, 46]]);
      }));

      function updateListing(_x18, _x19, _x20) {
        return _updateListing.apply(this, arguments);
      }

      return updateListing;
    }()
    /**
     * Creates Cancel Listing transaction Object
     * @param mint
     * @param currentListingPrice
     * @param sellerPublicKey
     * @param auctionHouseAuthority
     * @param connection
     * @param __DANGEROUSLY_INSET_SELLER__
     */

  }, {
    key: "createCancelListingTransaction",
    value: function () {
      var _createCancelListingTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(mint, currentListingPrice, sellerPublicKey) {
        var auctionHouseAuthority,
            connection,
            __DANGEROUSLY_INSET_SELLER__,
            _yield$this$getAuctio9,
            _yield$this$getAuctio10,
            _args14 = arguments;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                auctionHouseAuthority = _args14.length > 3 && _args14[3] !== undefined ? _args14[3] : this.auctionHouseAuthority;
                connection = _args14.length > 4 && _args14[4] !== undefined ? _args14[4] : this.connection;
                __DANGEROUSLY_INSET_SELLER__ = _args14.length > 5 ? _args14[5] : undefined;

                if (!this.wallet) {
                  throwError('WALLET_NOT_INITIALIZED');
                }

                if (!this.auctionHouse) {
                  throwError('AUCTION_HOUSE_NOT_INITIALIZED');
                }

                if (this.auctionHouse) {
                  _context14.next = 11;
                  break;
                }

                _context14.next = 8;
                return this.getAuctionHouseAddress();

              case 8:
                _yield$this$getAuctio9 = _context14.sent;
                _yield$this$getAuctio10 = _slicedToArray(_yield$this$getAuctio9, 1);
                this.auctionHouse = _yield$this$getAuctio10[0];

              case 11:
                if (this.program) {
                  _context14.next = 15;
                  break;
                }

                _context14.next = 14;
                return this.loadAuctionHouseProgram();

              case 14:
                this.program = _context14.sent;

              case 15:
                if (!this.program) {
                  throwError('PROGRAM_NOT_INITIALIZED');
                }

                return _context14.abrupt("return", createCancelListingTransaction(mint, currentListingPrice, sellerPublicKey, this.auctionHouse, this.program, auctionHouseAuthority, connection, __DANGEROUSLY_INSET_SELLER__));

              case 17:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function createCancelListingTransaction$1(_x21, _x22, _x23) {
        return _createCancelListingTransaction2.apply(this, arguments);
      }

      return createCancelListingTransaction$1;
    }()
    /**
     * Cancels a listing for sell or buy instructions for an NFT
     * @param mint NFT mint address whose listing is to be cancelled
     * @param currentListingPrice price at which NFT was listed
     * @param tradeState optional: trade state address to cancel
     */

  }, {
    key: "cancelListing",
    value: function () {
      var _cancelListing = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(mint, currentListingPrice, __DANGEROUSLY_INSET_SELLER__) {
        var sellerPublicKey, _yield$this$createCan, _yield$this$createCan2, txt, receipt, estimatedCost, _yield$this$connectio4, _balance, balance, signed, signature, result, ListingReceipt;

        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                sellerPublicKey = this.wallet.publicKey;
                _context15.next = 3;
                return this.createCancelListingTransaction(new PublicKey(mint), currentListingPrice, sellerPublicKey, undefined, undefined, __DANGEROUSLY_INSET_SELLER__);

              case 3:
                _yield$this$createCan = _context15.sent;
                _yield$this$createCan2 = _slicedToArray(_yield$this$createCan, 2);
                txt = _yield$this$createCan2[0];
                receipt = _yield$this$createCan2[1];
                _context15.next = 9;
                return this.connection.getLatestBlockhash();

              case 9:
                txt.recentBlockhash = _context15.sent.blockhash;
                txt.feePayer = this.wallet.publicKey;
                _context15.next = 13;
                return txt.getEstimatedFee(this.connection);

              case 13:
                _context15.t0 = _context15.sent;
                _context15.t1 = LAMPORTS_PER_SOL;
                estimatedCost = _context15.t0 / _context15.t1;
                _context15.next = 18;
                return this.connection.getBalanceAndContext(this.wallet.publicKey);

              case 18:
                _yield$this$connectio4 = _context15.sent;
                _balance = _yield$this$connectio4.value;
                balance = _balance / LAMPORTS_PER_SOL;
                console.info('Estimated cost of transaction: ', estimatedCost);
                console.info('Wallet Balance', balance, '');

                if (!(balance < estimatedCost)) {
                  _context15.next = 25;
                  break;
                }

                throw new InsufficientBalanceError('Account balance is not enough to complete this cancel listing transaction');

              case 25:
                signed = undefined;
                _context15.prev = 26;
                _context15.next = 29;
                return this.wallet.signTransaction(txt);

              case 29:
                signed = _context15.sent;
                _context15.next = 36;
                break;

              case 32:
                _context15.prev = 32;
                _context15.t2 = _context15["catch"](26);
                console.error('Seller cancelled transaction', _context15.t2.message);
                throw _context15.t2;

              case 36:
                console.info('Sending the transaction to Solana.');
                signature = undefined;
                _context15.prev = 38;
                _context15.next = 41;
                return this.connection.sendRawTransaction(signed.serialize());

              case 41:
                signature = _context15.sent;
                _context15.next = 44;
                return this.connection.confirmTransaction(signature, 'confirmed');

              case 44:
                result = _context15.sent;
                _context15.next = 50;
                break;

              case 47:
                _context15.prev = 47;
                _context15.t3 = _context15["catch"](38);
                programErrorHandler(_context15.t3);

              case 50:
                console.debug('result', result);
                console.debug('Successfully cancelled listing for mint ', mint, ' at ', currentListingPrice, ' SOL');
                _context15.next = 54;
                return AuctionHouseProgram.accounts.ListingReceipt.fromAccountAddress(this.connection, receipt);

              case 54:
                ListingReceipt = _context15.sent;
                console.debug('listingReceiptObj', JSON.stringify(ListingReceipt, null, 2));
                return _context15.abrupt("return", [result, receipt, signature]);

              case 57:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this, [[26, 32], [38, 47]]);
      }));

      function cancelListing(_x24, _x25, _x26) {
        return _cancelListing.apply(this, arguments);
      }

      return cancelListing;
    }()
    /**
     * Creates Transfer transaction Object
     * @param mint
     * @param recipient
     * @param holderPublicKey
     * @param auctionHouseAuthority
     * @param connection
     * @param __DANGEROUSLY_INSET_SELLER__
     */

  }, {
    key: "createTransferTransaction",
    value: function () {
      var _createTransferTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(mint, recipient, holderPublicKey) {
        var auctionHouseAuthority,
            connection,
            _yield$this$getAuctio11,
            _yield$this$getAuctio12,
            _args16 = arguments;

        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                auctionHouseAuthority = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : this.auctionHouseAuthority;
                connection = _args16.length > 4 && _args16[4] !== undefined ? _args16[4] : this.connection;

                if (!this.wallet) {
                  throwError('WALLET_NOT_INITIALIZED');
                }

                if (!this.auctionHouse) {
                  throwError('AUCTION_HOUSE_NOT_INITIALIZED');
                }

                if (this.auctionHouse) {
                  _context16.next = 11;
                  break;
                }

                _context16.next = 8;
                return this.getAuctionHouseAddress();

              case 8:
                _yield$this$getAuctio11 = _context16.sent;
                _yield$this$getAuctio12 = _slicedToArray(_yield$this$getAuctio11, 1);
                this.auctionHouse = _yield$this$getAuctio12[0];

              case 11:
                if (this.program) {
                  _context16.next = 15;
                  break;
                }

                _context16.next = 14;
                return this.loadAuctionHouseProgram();

              case 14:
                this.program = _context16.sent;

              case 15:
                if (!this.program) {
                  throwError('PROGRAM_NOT_INITIALIZED');
                }

                return _context16.abrupt("return", createTransferInstruction(mint, recipient, holderPublicKey, this.auctionHouse, auctionHouseAuthority, this.program, connection));

              case 17:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function createTransferTransaction(_x27, _x28, _x29) {
        return _createTransferTransaction.apply(this, arguments);
      }

      return createTransferTransaction;
    }()
    /**
     * Sends an NFT to a enw user.
     * @param mint NFT mint address to transfer to a new user
     * @param recipient Recipient's publicKey
     */

  }, {
    key: "transferNft",
    value: function () {
      var _transferNft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17(mint, recipient) {
        var _mint, _recipient, holderPublicKey, txt, estimatedCost, _yield$this$connectio5, _balance, balance, signed, signature, result;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _mint = new PublicKey(mint);
                _recipient = new PublicKey(recipient);
                holderPublicKey = this.wallet.publicKey;
                _context17.next = 5;
                return this.createTransferTransaction(_mint, _recipient, holderPublicKey);

              case 5:
                txt = _context17.sent;
                _context17.next = 8;
                return this.connection.getLatestBlockhash();

              case 8:
                txt.recentBlockhash = _context17.sent.blockhash;
                txt.feePayer = this.wallet.publicKey;
                _context17.next = 12;
                return txt.getEstimatedFee(this.connection);

              case 12:
                _context17.t0 = _context17.sent;
                _context17.t1 = LAMPORTS_PER_SOL;
                estimatedCost = _context17.t0 / _context17.t1;
                _context17.next = 17;
                return this.connection.getBalanceAndContext(this.wallet.publicKey);

              case 17:
                _yield$this$connectio5 = _context17.sent;
                _balance = _yield$this$connectio5.value;
                balance = _balance / LAMPORTS_PER_SOL;
                console.info('Estimated cost of transaction: ', estimatedCost);
                console.info('Wallet Balance', balance, '');

                if (!(balance < estimatedCost)) {
                  _context17.next = 24;
                  break;
                }

                throw new InsufficientBalanceError('Account balance is not enough to complete this transfer NFT transaction');

              case 24:
                signed = undefined;
                _context17.prev = 25;
                _context17.next = 28;
                return this.wallet.signTransaction(txt);

              case 28:
                signed = _context17.sent;
                _context17.next = 35;
                break;

              case 31:
                _context17.prev = 31;
                _context17.t2 = _context17["catch"](25);
                console.error('sender cancelled transaction', _context17.t2.message);
                throw _context17.t2;

              case 35:
                console.info('Sending the transaction to Solana.');
                signature = undefined;
                _context17.prev = 37;
                _context17.next = 40;
                return this.connection.sendRawTransaction(signed.serialize());

              case 40:
                signature = _context17.sent;
                _context17.next = 43;
                return this.connection.confirmTransaction(signature, 'confirmed');

              case 43:
                result = _context17.sent;
                _context17.next = 49;
                break;

              case 46:
                _context17.prev = 46;
                _context17.t3 = _context17["catch"](37);
                programErrorHandler(_context17.t3);

              case 49:
                console.log('result', result);
                console.log('Successfully transferred nft ', mint, ' from ', this.wallet.publicKey.toBase58(), ' to ', _recipient.toBase58());
                return _context17.abrupt("return", [result, signature]);

              case 52:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this, [[25, 31], [37, 46]]);
      }));

      function transferNft(_x30, _x31) {
        return _transferNft.apply(this, arguments);
      }

      return transferNft;
    }()
    /**
     * Mints a new NFT on Solana. There are 2 approaches to using this function.
     * 1. If you already have your files uploaded to the blockchain, then there is no
     *    need to perform a new upload. Simply provide the necessary metadata URI / tokenURI.
     * 2. If you choose to provide a file/image/video for your NFT, then it will be uploaded
     *    to a decentralized storage service before minting.
     * @param metadata Object for metadata according to Metaplex NFT standard. @see https://docs.metaplex.com/token-metadata/specification#full-metadata-struct
     * @param metadataLink URL for your token metadata. If provided, then upload is ignored.
     * @param file
     */

  }, {
    key: "mintNft",
    value: function () {
      var _mintNft = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(metadata, metadataLink, file) {
        var _metadata$properties;

        var creators, _metadata, finalMetadata, _yield$uploadNFTFileT, _yield$uploadNFTFileT2, metadataUrl;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                if (!(!metadata && !metadataLink)) {
                  _context18.next = 2;
                  break;
                }

                throw new Error('Expected metadata object or metadataURL to mint an NFT');

              case 2:
                creators = processCreatorShares(_toConsumableArray(merge([{
                  address: this.wallet.publicKey.toBase58(),
                  share: 100
                }], (_metadata$properties = metadata.properties) === null || _metadata$properties === void 0 ? void 0 : _metadata$properties.creators)), this.auctionHouseAuthority);
                /**
                 * 1. Metadata object
                 * 2. wallet instance to sign transaction
                 * 3. Upload to NFT.storage.
                 */

                if (metadataLink) {
                  _context18.next = 16;
                  break;
                }

                finalMetadata = merge(metadata, {
                  creators: creators,
                  properties: {
                    creators: creators
                  },
                  seller_fee_basis_points: this.mintConfig.seller_fee_basis_points
                }); // @ts-expect-error

                _context18.next = 7;
                return uploadNFTFileToStorage(null, finalMetadata, undefined, this.NFTStorageAPIKey);

              case 7:
                _yield$uploadNFTFileT = _context18.sent;
                _yield$uploadNFTFileT2 = _slicedToArray(_yield$uploadNFTFileT, 1);
                metadataUrl = _yield$uploadNFTFileT2[0];
                console.log('Uploaded metadata to:', metadataUrl); // const tokenAccount = await getAtaForMint()

                _context18.next = 13;
                return mintNFT({
                  connection: this.connection,
                  wallet: this.wallet,
                  uri: metadataUrl,
                  maxSupply: 1,
                  updateAuthority: this.auctionHouseAuthority
                });

              case 13:
                _metadata = _context18.sent;
                _context18.next = 19;
                break;

              case 16:
                _context18.next = 18;
                return mintNFT({
                  connection: this.connection,
                  wallet: this.wallet,
                  uri: metadataLink,
                  maxSupply: 1,
                  updateAuthority: this.auctionHouseAuthority
                });

              case 18:
                _metadata = _context18.sent;

              case 19:
                return _context18.abrupt("return", this.getNft(_metadata.mint));

              case 20:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function mintNft(_x32, _x33, _x34) {
        return _mintNft.apply(this, arguments);
      }

      return mintNft;
    }()
    /**
     * Get token transactions
     * @param mint
     */

  }, {
    key: "getTokenTransactions",
    value: function () {
      var _getTokenTransactions2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(mint) {
        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                return _context19.abrupt("return", getTokenTransactions(new PublicKey(mint), this.auctionHouse, this.connection));

              case 1:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function getTokenTransactions$1(_x35) {
        return _getTokenTransactions2.apply(this, arguments);
      }

      return getTokenTransactions$1;
    }()
    /**
     * Signs a transaction object
     * @param txt
     * @param wallet
     */

  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee20(txt, wallet) {
        var signedTransaction;
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return wallet.signTransaction(txt);

              case 2:
                signedTransaction = _context20.sent;
                return _context20.abrupt("return", signedTransaction.serialize());

              case 4:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20);
      }));

      function signTransaction(_x36, _x37) {
        return _signTransaction.apply(this, arguments);
      }

      return signTransaction;
    }()
  }]);

  return Mirage;
}();

var MetadataKey;

(function (MetadataKey) {
  MetadataKey[MetadataKey["Uninitialized"] = 0] = "Uninitialized";
  MetadataKey[MetadataKey["MetadataV1"] = 4] = "MetadataV1";
  MetadataKey[MetadataKey["EditionV1"] = 1] = "EditionV1";
  MetadataKey[MetadataKey["MasterEditionV1"] = 2] = "MasterEditionV1";
  MetadataKey[MetadataKey["MasterEditionV2"] = 6] = "MasterEditionV2";
  MetadataKey[MetadataKey["EditionMarker"] = 7] = "EditionMarker";
  MetadataKey[MetadataKey["UseAuthorityRecord"] = 8] = "UseAuthorityRecord";
  MetadataKey[MetadataKey["CollectionAuthorityRecord"] = 9] = "CollectionAuthorityRecord";
})(MetadataKey || (MetadataKey = {}));

var UseMethod;

(function (UseMethod) {
  UseMethod[UseMethod["Burn"] = 0] = "Burn";
  UseMethod[UseMethod["Single"] = 1] = "Single";
  UseMethod[UseMethod["Multiple"] = 2] = "Multiple";
})(UseMethod || (UseMethod = {}));

var Uses = /*#__PURE__*/function (_Borsh$Data) {
  _inherits(Uses, _Borsh$Data);

  var _super = _createSuper(Uses);

  // @ts-ignore
  function Uses(args) {
    var _this;

    _classCallCheck(this, Uses);

    _this = _super.call(this, args);
    _this.useMethod = args.useMethod;
    _this.total = args.total;
    _this.remaining = args.remaining;
    return _this;
  }

  return Uses;
}(Borsh.Data);

_defineProperty(Uses, "SCHEMA", Uses.struct([['useMethod', 'u8'], ['total', 'u64'], ['remaining', 'u64']]));

var SolanaNetwork;

(function (SolanaNetwork) {
  SolanaNetwork["mainnet"] = "mainnet-beta";
  SolanaNetwork["devnet"] = "devnet";
})(SolanaNetwork || (SolanaNetwork = {}));

var Creator = function Creator(args) {
  _classCallCheck(this, Creator);

  this.address = args.address;
  this.verified = args.verified;
  this.share = args.share;
};

export { AUCTION_HOUSE, AUCTION_HOUSE_PROGRAM_ID, AccountState, Creator, ENDPOINTS, MINT_CONFIG, MIRAGE_AUCTION_HOUSE, MIRAGE_AUCTION_HOUSE_AUTHORITY, MetadataKey, Mirage, NFT_STORAGE_API_KEY, SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID, SequenceType, SolanaNetwork, TOKEN_METADATA_PROGRAM_ID, UseMethod, Uses, WRAPPED_SOL_MINT, chunks, getAccountInfo, getAtaForMint, getAuctionHouseBuyerEscrow, getAuctionHouseProgramAsSigner, getAuctionHouseTradeState, getErrorForTransaction, getMetadata, getNftOwner, getTokenTransactions, getUnixTs, processCreatorShares, sendSignedTransaction, sendTransaction, sendTransactionWithRetry, sendTransactions, sendTransactionsInChunks, sendTransactionsWithManualRetry, sendTransactionsWithRecentBlock, sleep, index as transactions, uploadNFTFileToStorage };
