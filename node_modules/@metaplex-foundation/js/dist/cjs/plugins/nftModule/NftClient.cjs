'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.cjs');
var approveNftCollectionAuthority = require('./approveNftCollectionAuthority.cjs');
var approveNftUseAuthority = require('./approveNftUseAuthority.cjs');
var createNft = require('./createNft.cjs');
var createSft = require('./createSft.cjs');
var deleteNft = require('./deleteNft.cjs');
var findNftByMetadata = require('./findNftByMetadata.cjs');
var findNftByMint = require('./findNftByMint.cjs');
var findNftByToken = require('./findNftByToken.cjs');
var findNftsByCreator = require('./findNftsByCreator.cjs');
var findNftsByMintList = require('./findNftsByMintList.cjs');
var findNftsByOwner = require('./findNftsByOwner.cjs');
var findNftsByUpdateAuthority = require('./findNftsByUpdateAuthority.cjs');
var freezeDelegatedNft = require('./freezeDelegatedNft.cjs');
var helpers = require('./helpers.cjs');
var loadMetadata = require('./loadMetadata.cjs');
var migrateToSizedCollectionNft = require('./migrateToSizedCollectionNft.cjs');
var NftBuildersClient = require('./NftBuildersClient.cjs');
var printNewEdition = require('./printNewEdition.cjs');
var revokeNftCollectionAuthority = require('./revokeNftCollectionAuthority.cjs');
var revokeNftUseAuthority = require('./revokeNftUseAuthority.cjs');
var thawDelegatedNft = require('./thawDelegatedNft.cjs');
var unverifyNftCollection = require('./unverifyNftCollection.cjs');
var unverifyNftCreator = require('./unverifyNftCreator.cjs');
var updateNft = require('./updateNft.cjs');
var uploadMetadata = require('./uploadMetadata.cjs');
var useNft = require('./useNft.cjs');
var verifyNftCollection = require('./verifyNftCollection.cjs');
var verifyNftCreator = require('./verifyNftCreator.cjs');
var Amount = require('../../types/Amount.cjs');

class NftClient {
  constructor(metaplex) {
    _rollupPluginBabelHelpers.defineProperty(this, "findByMint", findNftByMint._findNftByMintClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findByMetadata", findNftByMetadata._findNftByMetadataClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findByToken", findNftByToken._findNftByTokenClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findAllByCreator", findNftsByCreator._findNftsByCreatorsClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findAllByMintList", findNftsByMintList._findNftsByMintListClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findAllByOwner", findNftsByOwner._findNftsByOwnerClient);

    _rollupPluginBabelHelpers.defineProperty(this, "findAllByUpdateAuthority", findNftsByUpdateAuthority._findNftsByUpdateAuthorityClient);

    _rollupPluginBabelHelpers.defineProperty(this, "refresh", findNftByMint._refreshNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "load", loadMetadata._loadMetadataClient);

    _rollupPluginBabelHelpers.defineProperty(this, "create", createNft._createNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "createSft", createSft._createSftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "printNewEdition", printNewEdition._printNewEditionClient);

    _rollupPluginBabelHelpers.defineProperty(this, "uploadMetadata", uploadMetadata._uploadMetadataClient);

    _rollupPluginBabelHelpers.defineProperty(this, "update", updateNft._updateNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "delete", deleteNft._deleteNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "use", useNft._useNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "approveUseAuthority", approveNftUseAuthority._approveNftUseAuthorityClient);

    _rollupPluginBabelHelpers.defineProperty(this, "revokeUseAuthority", revokeNftUseAuthority._revokeNftUseAuthorityClient);

    _rollupPluginBabelHelpers.defineProperty(this, "verifyCreator", verifyNftCreator._verifyNftCreatorClient);

    _rollupPluginBabelHelpers.defineProperty(this, "unverifyCreator", unverifyNftCreator._unverifyNftCreatorClient);

    _rollupPluginBabelHelpers.defineProperty(this, "verifyCollection", verifyNftCollection._verifyNftCollectionClient);

    _rollupPluginBabelHelpers.defineProperty(this, "unverifyCollection", unverifyNftCollection._unverifyNftCollectionClient);

    _rollupPluginBabelHelpers.defineProperty(this, "approveCollectionAuthority", approveNftCollectionAuthority._approveNftCollectionAuthorityClient);

    _rollupPluginBabelHelpers.defineProperty(this, "revokeCollectionAuthority", revokeNftCollectionAuthority._revokeNftCollectionAuthorityClient);

    _rollupPluginBabelHelpers.defineProperty(this, "migrateToSizedCollection", migrateToSizedCollectionNft._migrateToSizedCollectionNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "freezeDelegatedNft", freezeDelegatedNft._freezeDelegatedNftClient);

    _rollupPluginBabelHelpers.defineProperty(this, "thawDelegatedNft", thawDelegatedNft._thawDelegatedNftClient);

    this.metaplex = metaplex;
  }

  builders() {
    return new NftBuildersClient.NftBuildersClient(this.metaplex);
  } // Queries.


  // Syntactic sugar.
  send(nftOrSft, options) {
    return this.metaplex.tokens().send({
      mint: helpers.toMintAddress(nftOrSft),
      amount: Amount.token(1),
      ...options
    });
  }

  approveDelegateAuthority(nftOrSft, options) {
    return this.metaplex.tokens().approveDelegateAuthority({
      mintAddress: helpers.toMintAddress(nftOrSft),
      ...options
    });
  }

  revokeDelegateAuthority(nftOrSft, options) {
    return this.metaplex.tokens().revokeDelegateAuthority({
      mintAddress: helpers.toMintAddress(nftOrSft),
      ...options
    });
  }

}

exports.NftClient = NftClient;
//# sourceMappingURL=NftClient.cjs.map
