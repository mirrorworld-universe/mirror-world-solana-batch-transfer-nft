{"version":3,"file":"findNftByMint.cjs","sources":["../../../../src/plugins/nftModule/findNftByMint.ts"],"sourcesContent":["import { Commitment, PublicKey } from '@solana/web3.js';\nimport { Metaplex } from '@/Metaplex';\nimport { findMasterEditionV2Pda, findMetadataPda } from './pdas';\nimport {\n  parseOriginalOrPrintEditionAccount,\n  toMetadataAccount,\n} from './accounts';\nimport { Operation, useOperation, OperationHandler } from '@/types';\nimport { DisposableScope, Task } from '@/utils';\nimport { Nft, NftWithToken, toNft, toNftWithToken } from './Nft';\nimport { Metadata, toMetadata } from './Metadata';\nimport { toNftEdition } from './NftEdition';\nimport {\n  findAssociatedTokenAccountPda,\n  toMint,\n  toMintAccount,\n  toToken,\n  toTokenAccount,\n} from '../tokenModule';\nimport { Sft, SftWithToken, toSft, toSftWithToken } from './Sft';\nimport { JsonMetadata } from './JsonMetadata';\nimport { toMintAddress } from './helpers';\nimport type { NftClient } from './NftClient';\n\n// -----------------\n// Clients\n// -----------------\n\n/** @internal */\nexport function _findNftByMintClient(\n  this: NftClient,\n  mint: PublicKey,\n  options?: Omit<FindNftByMintInput, 'mint'>\n) {\n  return this.metaplex\n    .operations()\n    .getTask(findNftByMintOperation({ mint, ...options }));\n}\n\n/** @internal */\nexport function _refreshNftClient<\n  T extends Nft | Sft | NftWithToken | SftWithToken | Metadata | PublicKey\n>(\n  this: NftClient,\n  nftOrSft: T,\n  options?: Omit<FindNftByMintInput, 'mint' | 'tokenAddres' | 'tokenOwner'>\n): Task<T extends Metadata | PublicKey ? Nft | Sft : T> {\n  return this.findByMint(toMintAddress(nftOrSft), {\n    tokenAddress: 'token' in nftOrSft ? nftOrSft.token.address : undefined,\n    ...options,\n  }) as Task<T extends Metadata | PublicKey ? Nft | Sft : T>;\n}\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindNftByMintOperation' as const;\nexport const findNftByMintOperation = useOperation<FindNftByMintOperation>(Key);\nexport type FindNftByMintOperation = Operation<\n  typeof Key,\n  FindNftByMintInput,\n  FindNftByMintOutput\n>;\n\nexport type FindNftByMintInput = {\n  mint: PublicKey;\n  tokenAddress?: PublicKey;\n  tokenOwner?: PublicKey;\n  loadJsonMetadata?: boolean;\n  commitment?: Commitment;\n};\n\nexport type FindNftByMintOutput = Nft | Sft | NftWithToken | SftWithToken;\n\n// -----------------\n// Handler\n// -----------------\n\nexport const findNftByMintOperationHandler: OperationHandler<FindNftByMintOperation> =\n  {\n    handle: async (\n      operation: FindNftByMintOperation,\n      metaplex: Metaplex,\n      scope: DisposableScope\n    ): Promise<FindNftByMintOutput> => {\n      const {\n        mint: mintAddress,\n        tokenAddress,\n        tokenOwner,\n        loadJsonMetadata = true,\n        commitment,\n      } = operation.input;\n\n      const associatedTokenAddress = tokenOwner\n        ? findAssociatedTokenAccountPda(mintAddress, tokenOwner)\n        : undefined;\n      const accountAddresses = [\n        mintAddress,\n        findMetadataPda(mintAddress),\n        findMasterEditionV2Pda(mintAddress),\n        tokenAddress ?? associatedTokenAddress,\n      ].filter((address): address is PublicKey => !!address);\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts(accountAddresses, commitment);\n      scope.throwIfCanceled();\n\n      const mint = toMint(toMintAccount(accounts[0]));\n      let metadata = toMetadata(toMetadataAccount(accounts[1]));\n      const editionAccount = parseOriginalOrPrintEditionAccount(accounts[2]);\n      const token = accounts[3] ? toToken(toTokenAccount(accounts[3])) : null;\n\n      if (loadJsonMetadata) {\n        try {\n          const json = await metaplex\n            .storage()\n            .downloadJson<JsonMetadata>(metadata.uri, scope);\n          metadata = { ...metadata, jsonLoaded: true, json };\n        } catch (error) {\n          metadata = { ...metadata, jsonLoaded: true, json: null };\n        }\n      }\n\n      const isNft =\n        editionAccount.exists &&\n        mint.mintAuthorityAddress &&\n        mint.mintAuthorityAddress.equals(editionAccount.publicKey);\n\n      if (isNft) {\n        const edition = toNftEdition(editionAccount);\n        return token\n          ? toNftWithToken(metadata, mint, edition, token)\n          : toNft(metadata, mint, edition);\n      }\n\n      return token\n        ? toSftWithToken(metadata, mint, token)\n        : toSft(metadata, mint);\n    },\n  };\n"],"names":["_findNftByMintClient","mint","options","metaplex","operations","getTask","findNftByMintOperation","_refreshNftClient","nftOrSft","findByMint","toMintAddress","tokenAddress","token","address","undefined","Key","useOperation","findNftByMintOperationHandler","handle","operation","scope","mintAddress","tokenOwner","loadJsonMetadata","commitment","input","associatedTokenAddress","findAssociatedTokenAccountPda","accountAddresses","findMetadataPda","findMasterEditionV2Pda","filter","accounts","rpc","getMultipleAccounts","throwIfCanceled","toMint","toMintAccount","metadata","toMetadata","toMetadataAccount","editionAccount","parseOriginalOrPrintEditionAccount","toToken","toTokenAccount","json","storage","downloadJson","uri","jsonLoaded","error","isNft","exists","mintAuthorityAddress","equals","publicKey","edition","toNftEdition","toNftWithToken","toNft","toSftWithToken","toSft"],"mappings":"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"}