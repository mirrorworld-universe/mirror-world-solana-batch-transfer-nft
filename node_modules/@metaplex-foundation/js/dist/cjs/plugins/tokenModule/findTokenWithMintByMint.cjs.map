{"version":3,"file":"findTokenWithMintByMint.cjs","sources":["../../../../src/plugins/tokenModule/findTokenWithMintByMint.ts"],"sourcesContent":["import { Metaplex } from '@/Metaplex';\nimport { Operation, OperationHandler, useOperation } from '@/types';\nimport type { Commitment, PublicKey } from '@solana/web3.js';\nimport { toMintAccount, toTokenAccount } from './accounts';\nimport { TokenAndMintDoNotMatchError } from './errors';\nimport { toMint } from './Mint';\nimport { findAssociatedTokenAccountPda } from './pdas';\nimport { TokenWithMint, toTokenWithMint } from './Token';\nimport type { TokenClient } from './TokenClient';\n\n// -----------------\n// Clients\n// -----------------\n\n/** @internal */\nexport function _findTokenWithMintByMintClient(\n  this: TokenClient,\n  input: FindTokenWithMintByMintInput\n) {\n  return this.metaplex\n    .operations()\n    .getTask(findTokenWithMintByMintOperation(input));\n}\n\n// -----------------\n// Operation\n// -----------------\n\nconst Key = 'FindTokenWithMintByMintOperation' as const;\nexport const findTokenWithMintByMintOperation =\n  useOperation<FindTokenWithMintByMintOperation>(Key);\nexport type FindTokenWithMintByMintOperation = Operation<\n  typeof Key,\n  FindTokenWithMintByMintInput,\n  TokenWithMint\n>;\n\nexport type FindTokenWithMintByMintInput = {\n  mint: PublicKey;\n  address: PublicKey;\n  addressType: 'owner' | 'token';\n  commitment?: Commitment;\n};\n\n// -----------------\n// Handler\n// -----------------\n\nexport const findTokenWithMintByMintOperationHandler: OperationHandler<FindTokenWithMintByMintOperation> =\n  {\n    handle: async (\n      operation: FindTokenWithMintByMintOperation,\n      metaplex: Metaplex\n    ): Promise<TokenWithMint> => {\n      const { mint, address, addressType, commitment } = operation.input;\n      const tokenAddress =\n        addressType === 'owner'\n          ? findAssociatedTokenAccountPda(mint, address)\n          : address;\n\n      const accounts = await metaplex\n        .rpc()\n        .getMultipleAccounts([mint, tokenAddress], commitment);\n\n      const mintAccount = toMintAccount(accounts[0]);\n      const tokenAccount = toTokenAccount(accounts[1]);\n\n      if (!tokenAccount.data.mint.equals(mint)) {\n        throw new TokenAndMintDoNotMatchError(\n          tokenAddress,\n          tokenAccount.data.mint,\n          mint\n        );\n      }\n\n      return toTokenWithMint(tokenAccount, toMint(mintAccount));\n    },\n  };\n"],"names":["_findTokenWithMintByMintClient","input","metaplex","operations","getTask","findTokenWithMintByMintOperation","Key","useOperation","findTokenWithMintByMintOperationHandler","handle","operation","mint","address","addressType","commitment","tokenAddress","findAssociatedTokenAccountPda","accounts","rpc","getMultipleAccounts","mintAccount","toMintAccount","tokenAccount","toTokenAccount","data","equals","TokenAndMintDoNotMatchError","toTokenWithMint","toMint"],"mappings":";;;;;;;;;;;AAUA;AACA;AACA;;AAEA;AACO,SAASA,8BAAT,CAELC,KAFK,EAGL;EACA,OAAO,IAAA,CAAKC,QAAL,CACJC,UADI,EAAA,CAEJC,OAFI,CAEIC,gCAAgC,CAACJ,KAAD,CAFpC,CAAP,CAAA;AAGD;AAGD;AACA;;AAEA,MAAMK,GAAG,GAAG,kCAAZ,CAAA;MACaD,gCAAgC,GAC3CE,sBAAY,CAAmCD,GAAnC,EADP;AAeP;AACA;AACA;AAEO,MAAME,uCAA2F,GACtG;AACEC,EAAAA,MAAM,EAAE,OACNC,SADM,EAENR,QAFM,KAGqB;IAC3B,MAAM;MAAES,IAAF;MAAQC,OAAR;MAAiBC,WAAjB;AAA8BC,MAAAA,UAAAA;KAAeJ,GAAAA,SAAS,CAACT,KAA7D,CAAA;AACA,IAAA,MAAMc,YAAY,GAChBF,WAAW,KAAK,OAAhB,GACIG,kCAA6B,CAACL,IAAD,EAAOC,OAAP,CADjC,GAEIA,OAHN,CAAA;AAKA,IAAA,MAAMK,UAAQ,GAAG,MAAMf,QAAQ,CAC5BgB,GADoB,EAEpBC,CAAAA,mBAFoB,CAEA,CAACR,IAAD,EAAOI,YAAP,CAFA,EAEsBD,UAFtB,CAAvB,CAAA;IAIA,MAAMM,WAAW,GAAGC,sBAAa,CAACJ,UAAQ,CAAC,CAAD,CAAT,CAAjC,CAAA;IACA,MAAMK,YAAY,GAAGC,uBAAc,CAACN,UAAQ,CAAC,CAAD,CAAT,CAAnC,CAAA;;IAEA,IAAI,CAACK,YAAY,CAACE,IAAb,CAAkBb,IAAlB,CAAuBc,MAAvB,CAA8Bd,IAA9B,CAAL,EAA0C;AACxC,MAAA,MAAM,IAAIe,kCAAJ,CACJX,YADI,EAEJO,YAAY,CAACE,IAAb,CAAkBb,IAFd,EAGJA,IAHI,CAAN,CAAA;AAKD,KAAA;;IAED,OAAOgB,qBAAe,CAACL,YAAD,EAAeM,WAAM,CAACR,WAAD,CAArB,CAAtB,CAAA;AACD,GAAA;AA3BH;;;;;;"}