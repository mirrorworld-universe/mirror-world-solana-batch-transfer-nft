import type { Metaplex } from '../../Metaplex';
import { ApproveTokenDelegateAuthorityInput, RevokeTokenDelegateAuthorityInput, SendTokensInput } from '../tokenModule';
import { _approveNftCollectionAuthorityClient } from './approveNftCollectionAuthority';
import { _approveNftUseAuthorityClient } from './approveNftUseAuthority';
import { _createNftClient } from './createNft';
import { _createSftClient } from './createSft';
import { _deleteNftClient } from './deleteNft';
import { _findNftByMetadataClient } from './findNftByMetadata';
import { _findNftByMintClient, _refreshNftClient } from './findNftByMint';
import { _findNftByTokenClient } from './findNftByToken';
import { _findNftsByCreatorsClient } from './findNftsByCreator';
import { _findNftsByMintListClient } from './findNftsByMintList';
import { _findNftsByOwnerClient } from './findNftsByOwner';
import { _findNftsByUpdateAuthorityClient } from './findNftsByUpdateAuthority';
import { _freezeDelegatedNftClient } from './freezeDelegatedNft';
import { HasMintAddress } from './helpers';
import { _loadMetadataClient } from './loadMetadata';
import { _migrateToSizedCollectionNftClient } from './migrateToSizedCollectionNft';
import { NftBuildersClient } from './NftBuildersClient';
import { _printNewEditionClient } from './printNewEdition';
import { _revokeNftCollectionAuthorityClient } from './revokeNftCollectionAuthority';
import { _revokeNftUseAuthorityClient } from './revokeNftUseAuthority';
import { _thawDelegatedNftClient } from './thawDelegatedNft';
import { _unverifyNftCollectionClient } from './unverifyNftCollection';
import { _unverifyNftCreatorClient } from './unverifyNftCreator';
import { _updateNftClient } from './updateNft';
import { _uploadMetadataClient } from './uploadMetadata';
import { _useNftClient } from './useNft';
import { _verifyNftCollectionClient } from './verifyNftCollection';
import { _verifyNftCreatorClient } from './verifyNftCreator';
export declare class NftClient {
    protected readonly metaplex: Metaplex;
    constructor(metaplex: Metaplex);
    builders(): NftBuildersClient;
    findByMint: typeof _findNftByMintClient;
    findByMetadata: typeof _findNftByMetadataClient;
    findByToken: typeof _findNftByTokenClient;
    findAllByCreator: typeof _findNftsByCreatorsClient;
    findAllByMintList: typeof _findNftsByMintListClient;
    findAllByOwner: typeof _findNftsByOwnerClient;
    findAllByUpdateAuthority: typeof _findNftsByUpdateAuthorityClient;
    refresh: typeof _refreshNftClient;
    load: typeof _loadMetadataClient;
    create: typeof _createNftClient;
    createSft: typeof _createSftClient;
    printNewEdition: typeof _printNewEditionClient;
    uploadMetadata: typeof _uploadMetadataClient;
    update: typeof _updateNftClient;
    delete: typeof _deleteNftClient;
    use: typeof _useNftClient;
    approveUseAuthority: typeof _approveNftUseAuthorityClient;
    revokeUseAuthority: typeof _revokeNftUseAuthorityClient;
    verifyCreator: typeof _verifyNftCreatorClient;
    unverifyCreator: typeof _unverifyNftCreatorClient;
    verifyCollection: typeof _verifyNftCollectionClient;
    unverifyCollection: typeof _unverifyNftCollectionClient;
    approveCollectionAuthority: typeof _approveNftCollectionAuthorityClient;
    revokeCollectionAuthority: typeof _revokeNftCollectionAuthorityClient;
    migrateToSizedCollection: typeof _migrateToSizedCollectionNftClient;
    freezeDelegatedNft: typeof _freezeDelegatedNftClient;
    thawDelegatedNft: typeof _thawDelegatedNftClient;
    send(nftOrSft: HasMintAddress, options?: Omit<SendTokensInput, 'mint'>): import("../..").Task<import("../tokenModule").SendTokensOutput, []>;
    approveDelegateAuthority(nftOrSft: HasMintAddress, options: Omit<ApproveTokenDelegateAuthorityInput, 'mintAddress'>): import("../..").Task<import("../tokenModule").ApproveTokenDelegateAuthorityOutput, []>;
    revokeDelegateAuthority(nftOrSft: HasMintAddress, options?: Omit<RevokeTokenDelegateAuthorityInput, 'mintAddress'>): import("../..").Task<import("../tokenModule").RevokeTokenDelegateAuthorityOutput, []>;
}
