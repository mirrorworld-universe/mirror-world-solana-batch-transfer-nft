import { createListingOperation } from './createListing.mjs';
import { findListingByAddressOperation } from './findListingByAddress.mjs';
import { loadListingOperation } from './loadListing.mjs';
import { createBidOperation } from './createBid.mjs';
import { findBidByAddressOperation } from './findBidByAddress.mjs';
import { loadBidOperation } from './loadBid.mjs';
import { executeSaleOperation } from './executeSale.mjs';
import { findPurchaseByAddressOperation } from './findPurchaseByAddress.mjs';
import { loadPurchaseOperation } from './loadPurchase.mjs';
import { now } from '../../types/DateTime.mjs';
import { Task } from '../../utils/Task.mjs';

class AuctionHouseClient {
  constructor(metaplex, auctionHouse, auctioneerAuthority) {
    this.metaplex = metaplex;
    this.auctionHouse = auctionHouse;
    this.auctioneerAuthority = auctioneerAuthority;
  }

  executeSale(input) {
    return new Task(async scope => {
      const output = await this.metaplex.operations().execute(executeSaleOperation(this.addAH(input)));
      scope.throwIfCanceled();

      try {
        const purchase = await this.findPurchaseByAddress(output.sellerTradeState, output.buyerTradeState).run(scope);
        return {
          purchase,
          ...output
        };
      } catch (error) {// Fallback to manually creating a purchase from inputs and outputs.
      }

      const lazyPurchase = {
        model: 'purchase',
        lazy: true,
        auctionHouse: this.auctionHouse,
        buyerAddress: output.buyer,
        sellerAddress: output.seller,
        metadataAddress: output.metadata,
        bookkeeperAddress: output.bookkeeper,
        receiptAddress: output.receipt,
        price: output.price,
        tokens: output.tokens.basisPoints,
        createdAt: now()
      };
      return {
        purchase: await this.loadPurchase(lazyPurchase).run(scope),
        ...output
      };
    });
  }

  findPurchaseByAddress(sellerTradeState, buyerTradeState, options = {}) {
    return this.metaplex.operations().getTask(findPurchaseByAddressOperation({
      sellerTradeState,
      buyerTradeState,
      auctionHouse: this.auctionHouse,
      ...options
    }));
  }

  loadPurchase(lazyPurchase, options = {}) {
    return this.metaplex.operations().getTask(loadPurchaseOperation({
      lazyPurchase,
      ...options
    }));
  }

  list(input) {
    return new Task(async scope => {
      const output = await this.metaplex.operations().execute(createListingOperation(this.addAH(input)), scope);
      scope.throwIfCanceled();

      try {
        const listing = await this.findListingByAddress(output.sellerTradeState).run(scope);
        return {
          listing,
          ...output
        };
      } catch (error) {// Fallback to manually creating a listing from inputs and outputs.
      }

      scope.throwIfCanceled();
      const lazyListing = {
        model: 'listing',
        lazy: true,
        auctionHouse: this.auctionHouse,
        tradeStateAddress: output.sellerTradeState,
        bookkeeperAddress: output.bookkeeper,
        sellerAddress: output.seller,
        metadataAddress: output.metadata,
        receiptAddress: output.receipt,
        purchaseReceiptAddress: null,
        price: output.price,
        tokens: output.tokens.basisPoints,
        createdAt: now(),
        canceledAt: null
      };
      return {
        listing: await this.loadListing(lazyListing).run(scope),
        ...output
      };
    });
  }

  findListingByAddress(address, options = {}) {
    return this.metaplex.operations().getTask(findListingByAddressOperation({
      address,
      auctionHouse: this.auctionHouse,
      ...options
    }));
  }

  loadListing(lazyListing, options = {}) {
    return this.metaplex.operations().getTask(loadListingOperation({
      lazyListing,
      ...options
    }));
  }

  bid(input) {
    return new Task(async scope => {
      const output = await this.metaplex.operations().execute(createBidOperation(this.addAH(input)), scope);
      scope.throwIfCanceled();

      try {
        const bid = await this.findBidByAddress(output.buyerTradeState).run(scope);
        return {
          bid,
          ...output
        };
      } catch (error) {// Fallback to manually creating a bid from inputs and outputs.
      }

      scope.throwIfCanceled();
      const lazyBid = {
        model: 'bid',
        lazy: true,
        auctionHouse: this.auctionHouse,
        tradeStateAddress: output.buyerTradeState,
        bookkeeperAddress: output.bookkeeper,
        tokenAddress: output.tokenAccount,
        buyerAddress: output.buyer,
        metadataAddress: output.metadata,
        receiptAddress: output.receipt,
        purchaseReceiptAddress: null,
        isPublic: Boolean(output.tokenAccount),
        price: output.price,
        tokens: output.tokens.basisPoints,
        createdAt: now(),
        canceledAt: null
      };
      return {
        bid: await this.loadBid(lazyBid).run(scope),
        ...output
      };
    });
  }

  findBidByAddress(address, options = {}) {
    return this.metaplex.operations().getTask(findBidByAddressOperation({
      address,
      auctionHouse: this.auctionHouse,
      ...options
    }));
  }

  loadBid(lazyBid, options = {}) {
    return this.metaplex.operations().getTask(loadBidOperation({
      lazyBid,
      ...options
    }));
  }

  addAH(input) {
    return {
      auctionHouse: this.auctionHouse,
      auctioneerAuthority: this.auctioneerAuthority,
      ...input
    };
  }

}

export { AuctionHouseClient };
//# sourceMappingURL=AuctionHouseClient.mjs.map
