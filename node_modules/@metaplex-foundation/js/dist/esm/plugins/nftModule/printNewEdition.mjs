import { createMintNewEditionFromMasterEditionViaVaultProxyInstruction, createMintNewEditionFromMasterEditionViaTokenInstruction } from '@metaplex-foundation/mpl-token-metadata';
import { Keypair, PublicKey } from '@solana/web3.js';
import { toOriginalEditionAccount } from './accounts.mjs';
import { toMintAddress } from './helpers.mjs';
import { assertNftWithToken } from './Nft.mjs';
import { toNftOriginalEdition } from './NftEdition.mjs';
import { findMetadataPda, findMasterEditionV2Pda, findEditionMarkerPda, findEditionPda } from './pdas.mjs';
import { Task } from '../../utils/Task.mjs';
import { useOperation } from '../../types/Operation.mjs';
import { toBigNumber } from '../../types/BigNumber.mjs';
import { token } from '../../types/Amount.mjs';
import { findAssociatedTokenAccountPda } from '../tokenModule/pdas.mjs';
import { TransactionBuilder } from '../../utils/TransactionBuilder.mjs';

// Clients
// -----------------

/** @internal */

function _printNewEditionClient(originalNft, input = {}) {
  return new Task(async scope => {
    const originalMint = toMintAddress(originalNft);
    const operation = printNewEditionOperation({
      originalMint,
      ...input
    });
    const output = await this.metaplex.operations().execute(operation, scope);
    scope.throwIfCanceled();
    const nft = await this.findByMint(output.mintSigner.publicKey, {
      tokenAddress: output.tokenAddress
    }).run(scope);
    assertNftWithToken(nft);
    return { ...output,
      nft
    };
  });
}
/** @internal */

function _printNewEditionBuildersClient(input) {
  return printNewEditionBuilder(this.metaplex, input);
} // -----------------
// Operation
// -----------------

const Key = 'PrintNewEditionOperation';
const printNewEditionOperation = useOperation(Key);
// -----------------
// Handler
// -----------------
const printNewEditionOperationHandler = {
  handle: async (operation, metaplex, scope) => {
    const builder = await printNewEditionBuilder(metaplex, operation.input);
    scope.throwIfCanceled();
    return builder.sendAndConfirm(metaplex, operation.input.confirmOptions);
  }
}; // -----------------
// Builder
// -----------------

const printNewEditionBuilder = async (metaplex, params) => {
  const {
    originalMint,
    newMint = Keypair.generate(),
    newMintAuthority = metaplex.identity(),
    newUpdateAuthority = metaplex.identity().publicKey,
    newOwner = metaplex.identity().publicKey,
    newTokenAccount,
    newFreezeAuthority = metaplex.identity().publicKey,
    payer = metaplex.identity(),
    tokenProgram,
    associatedTokenProgram,
    printNewEditionInstructionKey = 'printNewEdition'
  } = params; // Original NFT.

  const originalMetadataAddress = findMetadataPda(originalMint);
  const originalEditionAddress = findMasterEditionV2Pda(originalMint);
  const originalEditionAccount = toOriginalEditionAccount(await metaplex.rpc().getAccount(originalEditionAddress));
  const originalEdition = toNftOriginalEdition(originalEditionAccount);
  const edition = toBigNumber(originalEdition.supply.addn(1));
  const updatedOriginalEdition = { ...originalEdition,
    supply: edition
  };
  const originalEditionMarkPda = findEditionMarkerPda(originalMint, edition); // New NFT.

  const newMetadataAddress = findMetadataPda(newMint.publicKey);
  const newEditionAddress = findEditionPda(newMint.publicKey);
  const sharedAccounts = {
    newMetadata: newMetadataAddress,
    newEdition: newEditionAddress,
    masterEdition: originalEditionAddress,
    newMint: newMint.publicKey,
    editionMarkPda: originalEditionMarkPda,
    newMintAuthority: newMintAuthority.publicKey,
    payer: payer.publicKey,
    newMetadataUpdateAuthority: newUpdateAuthority,
    metadata: originalMetadataAddress
  };
  const tokenWithMintBuilder = await metaplex.tokens().builders().createTokenWithMint({
    decimals: 0,
    initialSupply: token(1),
    mint: newMint,
    mintAuthority: newMintAuthority,
    freezeAuthority: newFreezeAuthority !== null && newFreezeAuthority !== void 0 ? newFreezeAuthority : null,
    owner: newOwner,
    token: newTokenAccount,
    payer,
    tokenProgram,
    associatedTokenProgram,
    createMintAccountInstructionKey: params.createMintAccountInstructionKey,
    initializeMintInstructionKey: params.initializeMintInstructionKey,
    createAssociatedTokenAccountInstructionKey: params.createAssociatedTokenAccountInstructionKey,
    createTokenAccountInstructionKey: params.createTokenAccountInstructionKey,
    initializeTokenInstructionKey: params.initializeTokenInstructionKey,
    mintTokensInstructionKey: params.mintTokensInstructionKey
  });
  const {
    tokenAddress
  } = tokenWithMintBuilder.getContext();
  let printNewEditionInstructionWithSigners;

  if (params.via === 'vault') {
    var _params$tokenVaultPro;

    printNewEditionInstructionWithSigners = {
      instruction: createMintNewEditionFromMasterEditionViaVaultProxyInstruction({ ...sharedAccounts,
        vaultAuthority: params.vaultAuthority.publicKey,
        safetyDepositStore: params.safetyDepositStore,
        safetyDepositBox: params.safetyDepositBox,
        vault: params.vault,
        tokenVaultProgram: (_params$tokenVaultPro = params.tokenVaultProgram) !== null && _params$tokenVaultPro !== void 0 ? _params$tokenVaultPro : new PublicKey('vau1zxA2LbssAUEF7Gpw91zMM1LvXrvpzJtmZ58rPsn')
      }, {
        mintNewEditionFromMasterEditionViaTokenArgs: {
          edition
        }
      }),
      signers: [newMint, newMintAuthority, payer, params.vaultAuthority],
      key: printNewEditionInstructionKey
    };
  } else {
    var _params$originalToken, _params$originalToken2;

    const originalTokenAccountOwner = (_params$originalToken = params.originalTokenAccountOwner) !== null && _params$originalToken !== void 0 ? _params$originalToken : metaplex.identity();
    const originalTokenAccount = (_params$originalToken2 = params.originalTokenAccount) !== null && _params$originalToken2 !== void 0 ? _params$originalToken2 : findAssociatedTokenAccountPda(originalMint, originalTokenAccountOwner.publicKey);
    printNewEditionInstructionWithSigners = {
      instruction: createMintNewEditionFromMasterEditionViaTokenInstruction({ ...sharedAccounts,
        tokenAccountOwner: originalTokenAccountOwner.publicKey,
        tokenAccount: originalTokenAccount
      }, {
        mintNewEditionFromMasterEditionViaTokenArgs: {
          edition
        }
      }),
      signers: [newMint, newMintAuthority, payer, originalTokenAccountOwner],
      key: printNewEditionInstructionKey
    };
  }

  return TransactionBuilder.make().setFeePayer(payer).setContext({
    mintSigner: newMint,
    metadataAddress: newMetadataAddress,
    editionAddress: newEditionAddress,
    tokenAddress,
    updatedOriginalEdition
  }) // Create the mint and token accounts before minting 1 token to the owner.
  .add(tokenWithMintBuilder) // Mint new edition.
  .add(printNewEditionInstructionWithSigners);
};

export { _printNewEditionBuildersClient, _printNewEditionClient, printNewEditionBuilder, printNewEditionOperation, printNewEditionOperationHandler };
//# sourceMappingURL=printNewEdition.mjs.map
